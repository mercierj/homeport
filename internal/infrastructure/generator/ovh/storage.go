// Package ovh generates Terraform configurations for OVHcloud deployments.
package ovh

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/homeport/homeport/internal/domain/generator"
	"github.com/homeport/homeport/internal/domain/mapper"
)

// OVH Object Storage classes (S3-compatible)
const (
	StorageClassStandard = "standard"  // High performance
	StorageClassHigh     = "high_perf" // High performance SSD
	StorageClassCold     = "cold"      // Cold archive storage
)

// OVH Block Storage volume types
const (
	VolumeTypeClassic    = "classic"    // Standard HDD
	VolumeTypeHighSpeed  = "high-speed" // High-speed SSD
	VolumeTypeHighSpeedGen2 = "high-speed-gen2" // Gen2 NVMe SSD
)

// generateStorageTF generates storage.tf for OVH object and block storage.
func (g *Generator) generateStorageTF(objectStorage, blockStorage []*mapper.MappingResult, config *generator.TargetConfig) string {
	var buf bytes.Buffer

	buf.WriteString("# OVH Storage Resources\n")
	buf.WriteString("# Generated by Homeport\n\n")

	region := getRegion(config)

	// Generate Object Storage containers (S3-compatible)
	if len(objectStorage) > 0 {
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n")
		buf.WriteString("# Object Storage Containers (OpenStack Swift / S3-compatible)\n")
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n\n")

		for _, res := range objectStorage {
			g.generateObjectStorageResource(&buf, res, config, region)
		}

		// Add S3 credentials output
		buf.WriteString("# S3-compatible credentials\n")
		buf.WriteString("resource \"ovh_cloud_project_user\" \"storage_user\" {\n")
		buf.WriteString("  service_name = var.ovh_project_id\n")
		buf.WriteString("  description  = \"${var.project_name} storage access user\"\n")
		buf.WriteString("  role_name    = \"objectstore_operator\"\n")
		buf.WriteString("}\n\n")

		buf.WriteString("resource \"ovh_cloud_project_user_s3_credential\" \"storage_creds\" {\n")
		buf.WriteString("  service_name = var.ovh_project_id\n")
		buf.WriteString("  user_id      = ovh_cloud_project_user.storage_user.id\n")
		buf.WriteString("}\n\n")
	}

	// Generate Block Storage volumes
	if len(blockStorage) > 0 {
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n")
		buf.WriteString("# Block Storage Volumes (OpenStack Cinder)\n")
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n\n")

		for _, res := range blockStorage {
			g.generateBlockStorageResource(&buf, res, config, region)
		}
	}

	return buf.String()
}

// generateObjectStorageResource generates a single object storage container.
func (g *Generator) generateObjectStorageResource(buf *bytes.Buffer, res *mapper.MappingResult, config *generator.TargetConfig, region string) {
	name := sanitizeName(res.SourceResource.Name)
	containerName := strings.ToLower(sanitizeName(res.SourceResource.Name))

	// Comment with source resource info
	buf.WriteString(fmt.Sprintf("# Source: %s (%s)\n", res.SourceResource.Type, res.SourceResource.Name))

	// OpenStack Swift container
	buf.WriteString(fmt.Sprintf("resource \"openstack_objectstorage_container_v1\" \"%s\" {\n", name))
	buf.WriteString(fmt.Sprintf("  name   = \"${var.project_name}-%s\"\n", containerName))
	buf.WriteString(fmt.Sprintf("  region = \"%s\"\n\n", region))

	// Container metadata
	buf.WriteString("  metadata = {\n")
	buf.WriteString("    managed_by  = \"homeport\"\n")
	buf.WriteString("    project     = var.project_name\n")
	buf.WriteString("    environment = var.environment\n")
	if res.SourceResource != nil {
		buf.WriteString(fmt.Sprintf("    source_type = \"%s\"\n", res.SourceResource.Type))
	}
	buf.WriteString("  }\n\n")

	// Versioning if enabled in source
	if versioning := getVersioningConfig(res); versioning {
		buf.WriteString("  versioning {\n")
		buf.WriteString("    type     = \"versions\"\n")
		buf.WriteString(fmt.Sprintf("    location = \"${var.project_name}-%s-versions\"\n", containerName))
		buf.WriteString("  }\n\n")
	}

	// Container ACL
	buf.WriteString("  container_read  = \".r:*,.rlistings\"\n")
	buf.WriteString("  container_write = \"\"\n")

	buf.WriteString("}\n\n")

	// Create versions container if versioning is enabled
	if getVersioningConfig(res) {
		buf.WriteString(fmt.Sprintf("resource \"openstack_objectstorage_container_v1\" \"%s_versions\" {\n", name))
		buf.WriteString(fmt.Sprintf("  name   = \"${var.project_name}-%s-versions\"\n", containerName))
		buf.WriteString(fmt.Sprintf("  region = \"%s\"\n\n", region))
		buf.WriteString("  metadata = {\n")
		buf.WriteString("    managed_by = \"homeport\"\n")
		buf.WriteString("    purpose    = \"versioning\"\n")
		buf.WriteString("  }\n")
		buf.WriteString("}\n\n")
	}

	// Lifecycle rules for cost optimization
	if lifecycle := getLifecycleConfig(res); lifecycle != "" {
		buf.WriteString(fmt.Sprintf("# Note: OVH Object Storage lifecycle rules via API\n"))
		buf.WriteString(fmt.Sprintf("# Configure via OVH Manager or s3cmd: %s\n\n", lifecycle))
	}
}

// generateBlockStorageResource generates a single block storage volume.
func (g *Generator) generateBlockStorageResource(buf *bytes.Buffer, res *mapper.MappingResult, config *generator.TargetConfig, region string) {
	name := sanitizeName(res.SourceResource.Name)
	sizeGB := getBlockStorageSize(res)
	volumeType := mapToOVHVolumeType(res)

	// Comment with source resource info
	buf.WriteString(fmt.Sprintf("# Source: %s (%s)\n", res.SourceResource.Type, res.SourceResource.Name))

	// OpenStack Cinder volume
	buf.WriteString(fmt.Sprintf("resource \"openstack_blockstorage_volume_v3\" \"%s\" {\n", name))
	buf.WriteString(fmt.Sprintf("  name        = \"${var.project_name}-%s\"\n", name))
	buf.WriteString(fmt.Sprintf("  size        = %d\n", sizeGB))
	buf.WriteString(fmt.Sprintf("  volume_type = \"%s\"\n", volumeType))
	buf.WriteString(fmt.Sprintf("  region      = \"%s\"\n\n", region))

	// Volume metadata
	buf.WriteString("  metadata = {\n")
	buf.WriteString("    managed_by  = \"homeport\"\n")
	buf.WriteString("    project     = var.project_name\n")
	buf.WriteString("    environment = var.environment\n")
	if res.SourceResource != nil {
		buf.WriteString(fmt.Sprintf("    source_type = \"%s\"\n", res.SourceResource.Type))
	}
	buf.WriteString("  }\n\n")

	// Lifecycle
	buf.WriteString("  lifecycle {\n")
	buf.WriteString("    prevent_destroy = true\n")
	buf.WriteString("  }\n")
	buf.WriteString("}\n\n")

	// Volume attachment placeholder (needs compute instance)
	buf.WriteString(fmt.Sprintf("# To attach volume to instance, uncomment:\n"))
	buf.WriteString(fmt.Sprintf("# resource \"openstack_compute_volume_attach_v2\" \"%s_attach\" {\n", name))
	buf.WriteString(fmt.Sprintf("#   instance_id = openstack_compute_instance_v2.INSTANCE_NAME.id\n"))
	buf.WriteString(fmt.Sprintf("#   volume_id   = openstack_blockstorage_volume_v3.%s.id\n", name))
	buf.WriteString(fmt.Sprintf("#   device      = \"/dev/vdb\"\n"))
	buf.WriteString(fmt.Sprintf("# }\n\n"))
}

// mapToOVHVolumeType maps source storage properties to OVH volume type.
func mapToOVHVolumeType(res *mapper.MappingResult) string {
	if res.SourceResource == nil {
		return VolumeTypeHighSpeed
	}

	// Check for volume type in properties
	if volumeType, ok := res.SourceResource.Config["volume_type"].(string); ok {
		volumeType = strings.ToLower(volumeType)

		// AWS EBS types
		switch {
		case strings.Contains(volumeType, "gp3") || strings.Contains(volumeType, "gp2"):
			return VolumeTypeHighSpeed
		case strings.Contains(volumeType, "io1") || strings.Contains(volumeType, "io2"):
			return VolumeTypeHighSpeedGen2
		case strings.Contains(volumeType, "st1") || strings.Contains(volumeType, "sc1"):
			return VolumeTypeClassic
		case strings.Contains(volumeType, "standard"):
			return VolumeTypeClassic
		}

		// GCP disk types
		switch {
		case strings.Contains(volumeType, "pd-ssd"):
			return VolumeTypeHighSpeed
		case strings.Contains(volumeType, "pd-extreme"):
			return VolumeTypeHighSpeedGen2
		case strings.Contains(volumeType, "pd-standard"):
			return VolumeTypeClassic
		}

		// Azure disk types
		switch {
		case strings.Contains(volumeType, "premium"):
			return VolumeTypeHighSpeedGen2
		case strings.Contains(volumeType, "standardssd"):
			return VolumeTypeHighSpeed
		case strings.Contains(volumeType, "standard"):
			return VolumeTypeClassic
		}
	}

	// Check for IOPS requirements
	if iops, ok := res.SourceResource.Config["iops"].(float64); ok {
		if iops > 10000 {
			return VolumeTypeHighSpeedGen2
		} else if iops > 3000 {
			return VolumeTypeHighSpeed
		}
	}

	return VolumeTypeHighSpeed // Default: high-speed SSD
}

// getVersioningConfig checks if versioning should be enabled.
func getVersioningConfig(res *mapper.MappingResult) bool {
	if res.SourceResource == nil {
		return false
	}

	// Check for versioning in properties
	if versioning, ok := res.SourceResource.Config["versioning"].(bool); ok {
		return versioning
	}

	// Check for versioning configuration
	if versioning, ok := res.SourceResource.Config["versioning_configuration"].(map[string]interface{}); ok {
		if status, ok := versioning["status"].(string); ok {
			return strings.ToLower(status) == "enabled"
		}
	}

	return false
}

// getLifecycleConfig extracts lifecycle configuration.
func getLifecycleConfig(res *mapper.MappingResult) string {
	if res.SourceResource == nil {
		return ""
	}

	// Check for lifecycle rules
	if lifecycle, ok := res.SourceResource.Config["lifecycle_rule"].([]interface{}); ok && len(lifecycle) > 0 {
		return "Lifecycle rules detected - configure via OVH API"
	}

	return ""
}

// getStorageClass maps source storage class to OVH.
func getStorageClass(res *mapper.MappingResult) string {
	if res.SourceResource == nil {
		return StorageClassStandard
	}

	// Check for storage class in properties
	if storageClass, ok := res.SourceResource.Config["storage_class"].(string); ok {
		storageClass = strings.ToLower(storageClass)

		switch {
		case strings.Contains(storageClass, "glacier") ||
			strings.Contains(storageClass, "archive") ||
			strings.Contains(storageClass, "coldline"):
			return StorageClassCold
		case strings.Contains(storageClass, "infrequent") ||
			strings.Contains(storageClass, "nearline"):
			return StorageClassStandard
		default:
			return StorageClassStandard
		}
	}

	return StorageClassStandard
}
