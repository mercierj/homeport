// Package ovh generates Terraform configurations for OVHcloud deployments.
package ovh

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/homeport/homeport/internal/domain/generator"
	"github.com/homeport/homeport/internal/domain/mapper"
	"github.com/homeport/homeport/internal/domain/target"
)

// OVH managed database engines
const (
	EnginePostgreSQL = "postgresql"
	EngineMySQL      = "mysql"
	EngineMongoDB    = "mongodb"
	EngineRedis      = "redis"
	EngineKafka      = "kafka"
	EngineCassandra  = "cassandra"
	EngineM3DB       = "m3db"
	EngineOpensearch = "opensearch"
	EngineGrafana    = "grafana"
)

// OVH database plans
const (
	PlanEssential  = "essential"  // Single node, development
	PlanBusiness   = "business"   // HA, production
	PlanEnterprise = "enterprise" // Advanced HA, large scale
)

// OVH database node flavors
var dbFlavors = map[string]string{
	"small":   "db1-4",  // 1 vCore, 4GB RAM
	"medium":  "db1-7",  // 2 vCores, 7GB RAM
	"large":   "db1-15", // 4 vCores, 15GB RAM
	"xlarge":  "db1-30", // 8 vCores, 30GB RAM
	"2xlarge": "db1-60", // 16 vCores, 60GB RAM
}

// Database versions supported by OVH
var databaseVersions = map[string]string{
	EnginePostgreSQL: "15",
	EngineMySQL:      "8",
	EngineMongoDB:    "6.0",
	EngineRedis:      "7.0",
	EngineKafka:      "3.5",
	EngineCassandra:  "4.1",
	EngineM3DB:       "1.5",
	EngineOpensearch: "2",
	EngineGrafana:    "9",
}

// generateDatabaseTF generates database.tf for OVH managed databases.
func (g *Generator) generateDatabaseTF(databases, cache []*mapper.MappingResult, config *generator.TargetConfig) string {
	var buf bytes.Buffer

	buf.WriteString("# OVH Managed Database Resources\n")
	buf.WriteString("# Generated by Homeport\n\n")

	region := getRegion(config)

	// Generate relational databases (PostgreSQL, MySQL)
	if len(databases) > 0 {
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n")
		buf.WriteString("# Managed Databases (ovh_cloud_project_database)\n")
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n\n")

		for _, res := range databases {
			g.generateDatabaseResource(&buf, res, config, region)
		}
	}

	// Generate cache instances (Redis)
	if len(cache) > 0 {
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n")
		buf.WriteString("# Cache Instances (Redis)\n")
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n\n")

		for _, res := range cache {
			g.generateCacheResource(&buf, res, config, region)
		}
	}

	return buf.String()
}

// generateDatabaseResource generates a single managed database.
func (g *Generator) generateDatabaseResource(buf *bytes.Buffer, res *mapper.MappingResult, config *generator.TargetConfig, region string) {
	name := sanitizeName(res.SourceResource.Name)
	engine := mapToOVHEngine(res)
	version := getEngineVersion(engine, res)
	plan := getPlanForHALevel(config.HALevel)
	flavor := getDBFlavor(res)
	nodeCount := getDBNodeCount(config.HALevel, engine)

	// Comment with source resource info
	buf.WriteString(fmt.Sprintf("# Source: %s (%s)\n", res.SourceResource.Type, res.SourceResource.Name))

	// Main database resource
	buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_database\" \"%s\" {\n", name))
	buf.WriteString("  service_name = var.ovh_project_id\n")
	buf.WriteString(fmt.Sprintf("  description  = \"${var.project_name}-%s\"\n", name))
	buf.WriteString(fmt.Sprintf("  engine       = \"%s\"\n", engine))
	buf.WriteString(fmt.Sprintf("  version      = \"%s\"\n", version))
	buf.WriteString(fmt.Sprintf("  plan         = \"%s\"\n", plan))
	buf.WriteString(fmt.Sprintf("  flavor       = \"%s\"\n\n", flavor))

	// Node configuration
	for i := 0; i < nodeCount; i++ {
		buf.WriteString("  nodes {\n")
		buf.WriteString(fmt.Sprintf("    region = \"%s\"\n", region))
		if i > 0 {
			buf.WriteString(fmt.Sprintf("    # Replica node %d\n", i))
		}
		buf.WriteString("  }\n\n")
	}

	// Advanced configuration
	if engine == EnginePostgreSQL || engine == EngineMySQL {
		buf.WriteString("  advanced_configuration = {\n")
		buf.WriteString("    \"pg.autovacuum_analyze_scale_factor\" = \"0.05\"\n")
		buf.WriteString("    \"pg.autovacuum_vacuum_scale_factor\"  = \"0.1\"\n")
		buf.WriteString("  }\n\n")
	}

	// Lifecycle
	buf.WriteString("  lifecycle {\n")
	buf.WriteString("    prevent_destroy = true\n")
	buf.WriteString("  }\n\n")

	// Timeouts
	buf.WriteString("  timeouts {\n")
	buf.WriteString("    create = \"30m\"\n")
	buf.WriteString("    update = \"30m\"\n")
	buf.WriteString("    delete = \"30m\"\n")
	buf.WriteString("  }\n")
	buf.WriteString("}\n\n")

	// Database user
	buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_database_user\" \"%s_user\" {\n", name))
	buf.WriteString("  service_name = var.ovh_project_id\n")
	buf.WriteString(fmt.Sprintf("  engine       = \"%s\"\n", engine))
	buf.WriteString(fmt.Sprintf("  cluster_id   = ovh_cloud_project_database.%s.id\n", name))
	buf.WriteString(fmt.Sprintf("  name         = \"%s_admin\"\n", name))
	buf.WriteString("}\n\n")

	// Create database (for SQL engines)
	if engine == EnginePostgreSQL || engine == EngineMySQL {
		buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_database_database\" \"%s_db\" {\n", name))
		buf.WriteString("  service_name = var.ovh_project_id\n")
		buf.WriteString(fmt.Sprintf("  engine       = \"%s\"\n", engine))
		buf.WriteString(fmt.Sprintf("  cluster_id   = ovh_cloud_project_database.%s.id\n", name))
		buf.WriteString(fmt.Sprintf("  name         = \"%s\"\n", sanitizeDBName(name)))
		buf.WriteString("}\n\n")
	}

	// IP whitelist (allow private network)
	buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_database_ip_restriction\" \"%s_private\" {\n", name))
	buf.WriteString("  service_name = var.ovh_project_id\n")
	buf.WriteString(fmt.Sprintf("  engine       = \"%s\"\n", engine))
	buf.WriteString(fmt.Sprintf("  cluster_id   = ovh_cloud_project_database.%s.id\n", name))
	buf.WriteString("  ip           = \"10.0.0.0/8\"\n")
	buf.WriteString("  description  = \"Private network access\"\n")
	buf.WriteString("}\n\n")
}

// generateCacheResource generates a Redis cache instance.
func (g *Generator) generateCacheResource(buf *bytes.Buffer, res *mapper.MappingResult, config *generator.TargetConfig, region string) {
	name := sanitizeName(res.SourceResource.Name)
	plan := getPlanForHALevel(config.HALevel)
	flavor := getCacheFlavor(res)
	nodeCount := getCacheNodeCount(config.HALevel)

	// Comment with source resource info
	buf.WriteString(fmt.Sprintf("# Source: %s (%s)\n", res.SourceResource.Type, res.SourceResource.Name))

	// Redis cluster
	buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_database\" \"%s\" {\n", name))
	buf.WriteString("  service_name = var.ovh_project_id\n")
	buf.WriteString(fmt.Sprintf("  description  = \"${var.project_name}-%s\"\n", name))
	buf.WriteString("  engine       = \"redis\"\n")
	buf.WriteString("  version      = \"7.0\"\n")
	buf.WriteString(fmt.Sprintf("  plan         = \"%s\"\n", plan))
	buf.WriteString(fmt.Sprintf("  flavor       = \"%s\"\n\n", flavor))

	// Node configuration
	for i := 0; i < nodeCount; i++ {
		buf.WriteString("  nodes {\n")
		buf.WriteString(fmt.Sprintf("    region = \"%s\"\n", region))
		buf.WriteString("  }\n\n")
	}

	// Lifecycle
	buf.WriteString("  lifecycle {\n")
	buf.WriteString("    prevent_destroy = true\n")
	buf.WriteString("  }\n\n")

	buf.WriteString("  timeouts {\n")
	buf.WriteString("    create = \"20m\"\n")
	buf.WriteString("    update = \"20m\"\n")
	buf.WriteString("    delete = \"20m\"\n")
	buf.WriteString("  }\n")
	buf.WriteString("}\n\n")

	// Redis user
	buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_database_user\" \"%s_user\" {\n", name))
	buf.WriteString("  service_name = var.ovh_project_id\n")
	buf.WriteString("  engine       = \"redis\"\n")
	buf.WriteString(fmt.Sprintf("  cluster_id   = ovh_cloud_project_database.%s.id\n", name))
	buf.WriteString(fmt.Sprintf("  name         = \"%s_user\"\n", name))
	buf.WriteString("}\n\n")

	// IP whitelist
	buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_database_ip_restriction\" \"%s_private\" {\n", name))
	buf.WriteString("  service_name = var.ovh_project_id\n")
	buf.WriteString("  engine       = \"redis\"\n")
	buf.WriteString(fmt.Sprintf("  cluster_id   = ovh_cloud_project_database.%s.id\n", name))
	buf.WriteString("  ip           = \"10.0.0.0/8\"\n")
	buf.WriteString("  description  = \"Private network access\"\n")
	buf.WriteString("}\n\n")
}

// mapToOVHEngine maps source database type to OVH engine.
func mapToOVHEngine(res *mapper.MappingResult) string {
	if res.SourceResource == nil {
		return EnginePostgreSQL
	}

	resourceType := strings.ToLower(string(res.SourceResource.Type))

	// Check resource type
	switch {
	case strings.Contains(resourceType, "mysql") || strings.Contains(resourceType, "aurora"):
		return EngineMySQL
	case strings.Contains(resourceType, "mongo") || strings.Contains(resourceType, "documentdb"):
		return EngineMongoDB
	case strings.Contains(resourceType, "redis") || strings.Contains(resourceType, "elasticache"):
		// Check engine property for elasticache
		if engine, ok := res.SourceResource.Config["engine"].(string); ok {
			if strings.Contains(strings.ToLower(engine), "redis") {
				return EngineRedis
			}
		}
		return EngineRedis
	case strings.Contains(resourceType, "kafka") || strings.Contains(resourceType, "msk"):
		return EngineKafka
	case strings.Contains(resourceType, "cassandra") || strings.Contains(resourceType, "keyspaces"):
		return EngineCassandra
	case strings.Contains(resourceType, "elasticsearch") || strings.Contains(resourceType, "opensearch"):
		return EngineOpensearch
	case strings.Contains(resourceType, "postgres") || strings.Contains(resourceType, "rds"):
		// Default RDS to PostgreSQL
		if engine, ok := res.SourceResource.Config["engine"].(string); ok {
			engine = strings.ToLower(engine)
			if strings.Contains(engine, "mysql") {
				return EngineMySQL
			}
		}
		return EnginePostgreSQL
	default:
		return EnginePostgreSQL
	}
}

// getEngineVersion returns the appropriate version for the engine.
func getEngineVersion(engine string, res *mapper.MappingResult) string {
	// Try to get version from source
	if res.SourceResource != nil {
		if version, ok := res.SourceResource.Config["engine_version"].(string); ok {
			// Map source version to OVH supported version
			switch engine {
			case EnginePostgreSQL:
				if strings.HasPrefix(version, "15") || strings.HasPrefix(version, "14") {
					return "15"
				} else if strings.HasPrefix(version, "13") {
					return "14"
				}
			case EngineMySQL:
				if strings.HasPrefix(version, "8") {
					return "8"
				}
			case EngineRedis:
				if strings.HasPrefix(version, "7") || strings.HasPrefix(version, "6") {
					return "7.0"
				}
			case EngineMongoDB:
				if strings.HasPrefix(version, "6") || strings.HasPrefix(version, "5") {
					return "6.0"
				}
			}
		}
	}

	// Return default version
	if version, ok := databaseVersions[engine]; ok {
		return version
	}
	return "15" // Default PostgreSQL version
}

// getPlanForHALevel returns the database plan for HA level.
func getPlanForHALevel(level target.HALevel) string {
	switch level {
	case target.HALevelGeo, target.HALevelCluster:
		return PlanEnterprise
	case target.HALevelMultiServer:
		return PlanBusiness
	default:
		return PlanEssential
	}
}

// getDBFlavor maps source database specs to OVH flavor.
func getDBFlavor(res *mapper.MappingResult) string {
	if res.SourceResource == nil {
		return "db1-7"
	}

	// Check for instance class
	if instanceClass, ok := res.SourceResource.Config["instance_class"].(string); ok {
		instanceClass = strings.ToLower(instanceClass)

		switch {
		case strings.Contains(instanceClass, "micro") || strings.Contains(instanceClass, "small"):
			return "db1-4"
		case strings.Contains(instanceClass, "medium"):
			return "db1-7"
		case strings.Contains(instanceClass, "large"):
			return "db1-15"
		case strings.Contains(instanceClass, "xlarge"):
			return "db1-30"
		case strings.Contains(instanceClass, "2xlarge"):
			return "db1-60"
		}
	}

	// Check for memory allocation
	if memory, ok := res.SourceResource.Config["allocated_memory"].(float64); ok {
		switch {
		case memory <= 4:
			return "db1-4"
		case memory <= 8:
			return "db1-7"
		case memory <= 16:
			return "db1-15"
		case memory <= 32:
			return "db1-30"
		default:
			return "db1-60"
		}
	}

	return "db1-7" // Default
}

// getCacheFlavor maps source cache specs to OVH flavor.
func getCacheFlavor(res *mapper.MappingResult) string {
	if res.SourceResource == nil {
		return "db1-4"
	}

	// Check for cache node type
	if nodeType, ok := res.SourceResource.Config["node_type"].(string); ok {
		nodeType = strings.ToLower(nodeType)

		switch {
		case strings.Contains(nodeType, "micro") || strings.Contains(nodeType, "small"):
			return "db1-4"
		case strings.Contains(nodeType, "medium"):
			return "db1-7"
		case strings.Contains(nodeType, "large"):
			return "db1-15"
		case strings.Contains(nodeType, "xlarge"):
			return "db1-30"
		}
	}

	return "db1-4" // Default for cache
}

// getDBNodeCount returns number of database nodes for HA level.
func getDBNodeCount(level target.HALevel, engine string) int {
	switch level {
	case target.HALevelGeo:
		return 3
	case target.HALevelCluster:
		if engine == EngineMongoDB {
			return 3 // MongoDB minimum replica set
		}
		return 2
	case target.HALevelMultiServer:
		return 2
	default:
		return 1
	}
}

// getCacheNodeCount returns number of cache nodes for HA level.
func getCacheNodeCount(level target.HALevel) int {
	switch level {
	case target.HALevelGeo, target.HALevelCluster:
		return 3
	case target.HALevelMultiServer:
		return 2
	default:
		return 1
	}
}

// sanitizeDBName creates a valid database name.
func sanitizeDBName(name string) string {
	// Remove invalid characters, database names are more restrictive
	result := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '_' {
			return r
		}
		return '_'
	}, strings.ToLower(name))

	// Ensure doesn't start with a number
	if len(result) > 0 && result[0] >= '0' && result[0] <= '9' {
		result = "db_" + result
	}

	// Truncate to reasonable length
	if len(result) > 63 {
		result = result[:63]
	}

	return result
}
