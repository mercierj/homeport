// Package ovh generates Terraform configurations for OVHcloud deployments.
package ovh

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/homeport/homeport/internal/domain/generator"
	"github.com/homeport/homeport/internal/domain/mapper"
	"github.com/homeport/homeport/internal/domain/target"
)

// OVH compute instance flavors by size category
var ovhFlavors = map[string]string{
	"micro":    "s1-2",   // 1 vCore, 2GB RAM
	"small":    "s1-4",   // 1 vCore, 4GB RAM
	"medium":   "b2-7",   // 2 vCores, 7GB RAM
	"large":    "b2-15",  // 4 vCores, 15GB RAM
	"xlarge":   "b2-30",  // 8 vCores, 30GB RAM
	"2xlarge":  "b2-60",  // 16 vCores, 60GB RAM
	"4xlarge":  "b2-120", // 32 vCores, 120GB RAM
	"compute":  "c2-7",   // CPU-optimized
	"memory":   "r2-15",  // RAM-optimized
	"gpu":      "t1-45",  // GPU instance
}

// OVH regions
var ovhRegions = []string{
	"GRA11", "GRA9", "GRA7",  // Gravelines, France
	"SBG5", "SBG3",           // Strasbourg, France
	"DE1",                     // Frankfurt, Germany
	"UK1",                     // London, UK
	"BHS5",                    // Beauharnois, Canada
	"WAW1",                    // Warsaw, Poland
	"SGP1",                    // Singapore
	"SYD1",                    // Sydney, Australia
}

// generateComputeTF generates compute.tf for OVH instances and Kubernetes.
func (g *Generator) generateComputeTF(compute, kubernetes []*mapper.MappingResult, config *generator.TargetConfig) string {
	var buf bytes.Buffer

	buf.WriteString("# OVH Compute Resources\n")
	buf.WriteString("# Generated by Homeport\n\n")

	region := getRegion(config)

	// SSH Key resource
	buf.WriteString("# SSH Key for instance access\n")
	buf.WriteString("resource \"openstack_compute_keypair_v2\" \"main\" {\n")
	buf.WriteString("  name       = \"${var.project_name}-key\"\n")
	buf.WriteString("  public_key = var.ssh_public_key\n")
	buf.WriteString("}\n\n")

	// Data source for Ubuntu image
	buf.WriteString("# Ubuntu 22.04 LTS image\n")
	buf.WriteString("data \"openstack_images_image_v2\" \"ubuntu\" {\n")
	buf.WriteString("  name        = \"Ubuntu 22.04\"\n")
	buf.WriteString("  most_recent = true\n")
	buf.WriteString("}\n\n")

	// Security group
	buf.WriteString("# Security group for compute instances\n")
	buf.WriteString("resource \"openstack_networking_secgroup_v2\" \"compute\" {\n")
	buf.WriteString("  name        = \"${var.project_name}-compute-sg\"\n")
	buf.WriteString("  description = \"Security group for compute instances\"\n")
	buf.WriteString("}\n\n")

	buf.WriteString("resource \"openstack_networking_secgroup_rule_v2\" \"ssh\" {\n")
	buf.WriteString("  direction         = \"ingress\"\n")
	buf.WriteString("  ethertype         = \"IPv4\"\n")
	buf.WriteString("  protocol          = \"tcp\"\n")
	buf.WriteString("  port_range_min    = 22\n")
	buf.WriteString("  port_range_max    = 22\n")
	buf.WriteString("  remote_ip_prefix  = var.admin_cidr\n")
	buf.WriteString("  security_group_id = openstack_networking_secgroup_v2.compute.id\n")
	buf.WriteString("}\n\n")

	buf.WriteString("resource \"openstack_networking_secgroup_rule_v2\" \"http\" {\n")
	buf.WriteString("  direction         = \"ingress\"\n")
	buf.WriteString("  ethertype         = \"IPv4\"\n")
	buf.WriteString("  protocol          = \"tcp\"\n")
	buf.WriteString("  port_range_min    = 80\n")
	buf.WriteString("  port_range_max    = 80\n")
	buf.WriteString("  remote_ip_prefix  = \"0.0.0.0/0\"\n")
	buf.WriteString("  security_group_id = openstack_networking_secgroup_v2.compute.id\n")
	buf.WriteString("}\n\n")

	buf.WriteString("resource \"openstack_networking_secgroup_rule_v2\" \"https\" {\n")
	buf.WriteString("  direction         = \"ingress\"\n")
	buf.WriteString("  ethertype         = \"IPv4\"\n")
	buf.WriteString("  protocol          = \"tcp\"\n")
	buf.WriteString("  port_range_min    = 443\n")
	buf.WriteString("  port_range_max    = 443\n")
	buf.WriteString("  remote_ip_prefix  = \"0.0.0.0/0\"\n")
	buf.WriteString("  security_group_id = openstack_networking_secgroup_v2.compute.id\n")
	buf.WriteString("}\n\n")

	// Generate compute instances
	if len(compute) > 0 {
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n")
		buf.WriteString("# Compute Instances (openstack_compute_instance_v2)\n")
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n\n")

		for _, res := range compute {
			g.generateInstanceResource(&buf, res, config, region)
		}
	}

	// Generate Kubernetes clusters
	if len(kubernetes) > 0 {
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n")
		buf.WriteString("# Managed Kubernetes Clusters (ovh_cloud_project_kube)\n")
		buf.WriteString("# ═══════════════════════════════════════════════════════════════════════════\n\n")

		for _, res := range kubernetes {
			g.generateKubernetesResource(&buf, res, config, region)
		}
	}

	return buf.String()
}

// generateInstanceResource generates a single compute instance.
func (g *Generator) generateInstanceResource(buf *bytes.Buffer, res *mapper.MappingResult, config *generator.TargetConfig, region string) {
	name := sanitizeName(res.SourceResource.Name)
	flavor := mapToOVHFlavor(res)
	instanceCount := getInstanceCountForHA(config.HALevel)

	// Comment with source resource info
	buf.WriteString(fmt.Sprintf("# Source: %s (%s)\n", res.SourceResource.Type, res.SourceResource.Name))

	if instanceCount > 1 {
		// Use count for HA
		buf.WriteString(fmt.Sprintf("resource \"openstack_compute_instance_v2\" \"%s\" {\n", name))
		buf.WriteString(fmt.Sprintf("  count = %d\n\n", instanceCount))
		buf.WriteString(fmt.Sprintf("  name        = \"${var.project_name}-%s-${count.index}\"\n", name))
	} else {
		buf.WriteString(fmt.Sprintf("resource \"openstack_compute_instance_v2\" \"%s\" {\n", name))
		buf.WriteString(fmt.Sprintf("  name        = \"${var.project_name}-%s\"\n", name))
	}

	buf.WriteString(fmt.Sprintf("  flavor_name = \"%s\"\n", flavor))
	buf.WriteString("  image_id    = data.openstack_images_image_v2.ubuntu.id\n")
	buf.WriteString("  key_pair    = openstack_compute_keypair_v2.main.name\n\n")

	buf.WriteString("  security_groups = [\n")
	buf.WriteString("    openstack_networking_secgroup_v2.compute.name,\n")
	buf.WriteString("  ]\n\n")

	// Network configuration
	buf.WriteString("  network {\n")
	buf.WriteString("    name = \"Ext-Net\"\n")
	buf.WriteString("  }\n\n")

	buf.WriteString("  network {\n")
	buf.WriteString("    uuid = openstack_networking_network_v2.main.id\n")
	buf.WriteString("  }\n\n")

	// User data for initial setup
	buf.WriteString("  user_data = <<-EOF\n")
	buf.WriteString("    #!/bin/bash\n")
	buf.WriteString("    apt-get update\n")
	buf.WriteString("    apt-get install -y docker.io docker-compose\n")
	buf.WriteString("    systemctl enable docker\n")
	buf.WriteString("    systemctl start docker\n")
	buf.WriteString("    usermod -aG docker ubuntu\n")
	buf.WriteString("  EOF\n\n")

	// Metadata
	buf.WriteString("  metadata = {\n")
	buf.WriteString("    managed_by   = \"homeport\"\n")
	buf.WriteString("    project      = var.project_name\n")
	buf.WriteString("    environment  = var.environment\n")
	if res.SourceResource != nil {
		buf.WriteString(fmt.Sprintf("    source_type  = \"%s\"\n", res.SourceResource.Type))
	}
	buf.WriteString("  }\n\n")

	// Lifecycle
	buf.WriteString("  lifecycle {\n")
	buf.WriteString("    create_before_destroy = true\n")
	buf.WriteString("  }\n")
	buf.WriteString("}\n\n")
}

// generateKubernetesResource generates an OVH Managed Kubernetes cluster.
func (g *Generator) generateKubernetesResource(buf *bytes.Buffer, res *mapper.MappingResult, config *generator.TargetConfig, region string) {
	name := sanitizeName(res.SourceResource.Name)
	nodeCount, nodeFlavor := getKubeNodeConfig(res, config)

	// Comment with source resource info
	buf.WriteString(fmt.Sprintf("# Source: %s (%s)\n", res.SourceResource.Type, res.SourceResource.Name))

	// Kubernetes cluster
	buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_kube\" \"%s\" {\n", name))
	buf.WriteString("  service_name = var.ovh_project_id\n")
	buf.WriteString(fmt.Sprintf("  name         = \"${var.project_name}-%s\"\n", name))
	buf.WriteString(fmt.Sprintf("  region       = \"%s\"\n", region))
	buf.WriteString("  version      = \"1.28\"\n\n")

	// Customization for private network
	buf.WriteString("  customization_apiserver {\n")
	buf.WriteString("    admissionplugins {\n")
	buf.WriteString("      enabled  = [\"AlwaysPullImages\", \"NodeRestriction\"]\n")
	buf.WriteString("      disabled = []\n")
	buf.WriteString("    }\n")
	buf.WriteString("  }\n\n")

	buf.WriteString("  private_network_id = openstack_networking_network_v2.main.id\n\n")

	buf.WriteString("  private_network_configuration {\n")
	buf.WriteString("    default_vrack_gateway              = \"\"\n")
	buf.WriteString("    private_network_routing_as_default = true\n")
	buf.WriteString("  }\n")
	buf.WriteString("}\n\n")

	// Node pool
	buf.WriteString(fmt.Sprintf("resource \"ovh_cloud_project_kube_nodepool\" \"%s_pool\" {\n", name))
	buf.WriteString("  service_name = var.ovh_project_id\n")
	buf.WriteString(fmt.Sprintf("  kube_id      = ovh_cloud_project_kube.%s.id\n", name))
	buf.WriteString(fmt.Sprintf("  name         = \"%s-pool\"\n", name))
	buf.WriteString(fmt.Sprintf("  flavor_name  = \"%s\"\n", nodeFlavor))
	buf.WriteString(fmt.Sprintf("  desired_nodes = %d\n", nodeCount))
	buf.WriteString(fmt.Sprintf("  min_nodes     = %d\n", nodeCount))
	buf.WriteString(fmt.Sprintf("  max_nodes     = %d\n", nodeCount*2))
	buf.WriteString("  autoscale     = true\n\n")

	buf.WriteString("  template {\n")
	buf.WriteString("    metadata {\n")
	buf.WriteString("      labels = {\n")
	buf.WriteString("        \"managed-by\" = \"homeport\"\n")
	buf.WriteString("      }\n")
	buf.WriteString("    }\n")
	buf.WriteString("  }\n")
	buf.WriteString("}\n\n")
}

// mapToOVHFlavor maps source resource properties to OVH flavor.
func mapToOVHFlavor(res *mapper.MappingResult) string {
	if res.SourceResource == nil {
		return "b2-7"
	}

	// Check for explicit instance type
	if instanceType, ok := res.SourceResource.Config["instance_type"].(string); ok {
		instanceType = strings.ToLower(instanceType)

		// AWS EC2 instance types
		switch {
		case strings.Contains(instanceType, "micro") || strings.Contains(instanceType, "nano"):
			return "s1-2"
		case strings.Contains(instanceType, "small"):
			return "s1-4"
		case strings.Contains(instanceType, "medium"):
			return "b2-7"
		case strings.Contains(instanceType, "large") && !strings.Contains(instanceType, "x"):
			return "b2-15"
		case strings.Contains(instanceType, "xlarge"):
			return "b2-30"
		case strings.Contains(instanceType, "2xlarge"):
			return "b2-60"
		case strings.Contains(instanceType, "4xlarge"):
			return "b2-120"
		}

		// GCP machine types
		switch {
		case strings.Contains(instanceType, "n1-standard-1") || strings.Contains(instanceType, "e2-micro"):
			return "s1-4"
		case strings.Contains(instanceType, "n1-standard-2"):
			return "b2-7"
		case strings.Contains(instanceType, "n1-standard-4"):
			return "b2-15"
		case strings.Contains(instanceType, "n1-standard-8"):
			return "b2-30"
		case strings.Contains(instanceType, "n1-standard-16"):
			return "b2-60"
		case strings.Contains(instanceType, "highmem"):
			return "r2-30"
		case strings.Contains(instanceType, "highcpu"):
			return "c2-15"
		}

		// Azure VM sizes
		switch {
		case strings.Contains(instanceType, "standard_b1"):
			return "s1-4"
		case strings.Contains(instanceType, "standard_b2"):
			return "b2-7"
		case strings.Contains(instanceType, "standard_d2"):
			return "b2-7"
		case strings.Contains(instanceType, "standard_d4"):
			return "b2-15"
		case strings.Contains(instanceType, "standard_d8"):
			return "b2-30"
		}
	}

	// Check for CPU/memory requirements
	if cpu, ok := res.SourceResource.Config["cpu"].(float64); ok {
		switch {
		case cpu <= 1:
			return "s1-4"
		case cpu <= 2:
			return "b2-7"
		case cpu <= 4:
			return "b2-15"
		case cpu <= 8:
			return "b2-30"
		case cpu <= 16:
			return "b2-60"
		default:
			return "b2-120"
		}
	}

	return "b2-7" // Default: 2 vCores, 7GB RAM
}

// getInstanceCountForHA returns instance count based on HA level.
func getInstanceCountForHA(level target.HALevel) int {
	switch level {
	case target.HALevelGeo:
		return 4
	case target.HALevelCluster:
		return 3
	case target.HALevelMultiServer:
		return 2
	default:
		return 1
	}
}
