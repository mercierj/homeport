// Package hetzner provides compute resource generation for Hetzner Cloud.
package hetzner

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/homeport/homeport/internal/domain/generator"
	"github.com/homeport/homeport/internal/domain/target"
)

// HetznerServerType represents a Hetzner Cloud server type with specs and pricing.
type HetznerServerType struct {
	Name   string
	CPU    int
	RAM    int     // GB
	Disk   int     // GB
	Price  float64 // EUR/month
	Series string  // cx = Intel, cpx = AMD, cax = ARM
}

// AvailableServerTypes returns all available Hetzner server types.
var AvailableServerTypes = map[string]HetznerServerType{
	// Intel (CX) series
	"cx11": {Name: "cx11", CPU: 1, RAM: 2, Disk: 20, Price: 3.49, Series: "cx"},
	"cx21": {Name: "cx21", CPU: 2, RAM: 4, Disk: 40, Price: 5.18, Series: "cx"},
	"cx31": {Name: "cx31", CPU: 2, RAM: 8, Disk: 80, Price: 9.18, Series: "cx"},
	"cx41": {Name: "cx41", CPU: 4, RAM: 16, Disk: 160, Price: 17.18, Series: "cx"},
	"cx51": {Name: "cx51", CPU: 8, RAM: 32, Disk: 240, Price: 33.18, Series: "cx"},
	// AMD (CPX) series - better value
	"cpx11": {Name: "cpx11", CPU: 2, RAM: 2, Disk: 40, Price: 4.59, Series: "cpx"},
	"cpx21": {Name: "cpx21", CPU: 3, RAM: 4, Disk: 80, Price: 8.39, Series: "cpx"},
	"cpx31": {Name: "cpx31", CPU: 4, RAM: 8, Disk: 160, Price: 15.49, Series: "cpx"},
	"cpx41": {Name: "cpx41", CPU: 8, RAM: 16, Disk: 240, Price: 29.69, Series: "cpx"},
	"cpx51": {Name: "cpx51", CPU: 16, RAM: 32, Disk: 360, Price: 59.69, Series: "cpx"},
	// ARM (CAX) series - most cost-effective
	"cax11": {Name: "cax11", CPU: 2, RAM: 4, Disk: 40, Price: 3.79, Series: "cax"},
	"cax21": {Name: "cax21", CPU: 4, RAM: 8, Disk: 80, Price: 7.49, Series: "cax"},
	"cax31": {Name: "cax31", CPU: 8, RAM: 16, Disk: 160, Price: 14.49, Series: "cax"},
	"cax41": {Name: "cax41", CPU: 16, RAM: 32, Disk: 320, Price: 28.49, Series: "cax"},
}

// RecommendServerType recommends a server type based on requirements.
func RecommendServerType(cpuCores int, memoryGB int) string {
	// Find the smallest server that meets requirements
	candidates := []string{
		"cax11", "cax21", "cax31", "cax41", // ARM first (best value)
		"cpx11", "cpx21", "cpx31", "cpx41", "cpx51", // AMD second
		"cx11", "cx21", "cx31", "cx41", "cx51", // Intel last
	}

	for _, name := range candidates {
		st := AvailableServerTypes[name]
		if st.CPU >= cpuCores && st.RAM >= memoryGB {
			return name
		}
	}

	// Default to cpx31 for general purpose
	return "cpx31"
}

// GenerateComputeTF generates Terraform configuration for compute resources.
func GenerateComputeTF(categorized *CategorizedResults, config *generator.TargetConfig, location string) string {
	var buf bytes.Buffer

	buf.WriteString("# Hetzner Cloud Compute Resources\n")
	buf.WriteString("# Generated by Homeport\n\n")

	serverCount := GetServerCount(config.HALevel)

	// Main application servers
	buf.WriteString("# Application Servers\n")
	buf.WriteString(fmt.Sprintf(`resource "hcloud_server" "app" {
  count       = var.server_count
  name        = "${local.project_name}-app-${count.index}"
  server_type = var.server_type
  location    = local.location
  image       = "ubuntu-22.04"
  ssh_keys    = [hcloud_ssh_key.default.id]

  user_data = data.template_cloudinit_config.docker.rendered

  labels = merge(local.common_labels, {
    role  = "app"
    index = count.index
  })

  public_net {
    ipv4_enabled = true
    ipv6_enabled = true
  }

  lifecycle {
    ignore_changes = [
      ssh_keys,
      user_data,
    ]
  }
}

`))

	// Server network attachment
	buf.WriteString("# Attach servers to private network\n")
	buf.WriteString(`resource "hcloud_server_network" "app" {
  count     = var.server_count
  server_id = hcloud_server.app[count.index].id
  network_id = hcloud_network.main.id
  ip        = cidrhost(hcloud_network_subnet.servers.ip_range, count.index + 10)
}

`)

	// For HA deployments, add dedicated database server
	if config.HALevel.RequiresMultiServer() && len(categorized.Database) > 0 {
		buf.WriteString("# Dedicated Database Server (for HA)\n")
		buf.WriteString(`resource "hcloud_server" "database" {
  count       = var.enable_dedicated_db ? 1 : 0
  name        = "${local.project_name}-db"
  server_type = var.db_server_type
  location    = local.location
  image       = "ubuntu-22.04"
  ssh_keys    = [hcloud_ssh_key.default.id]

  user_data = data.template_cloudinit_config.database.rendered

  labels = merge(local.common_labels, {
    role = "database"
  })

  public_net {
    ipv4_enabled = false
    ipv6_enabled = false
  }
}

resource "hcloud_server_network" "database" {
  count      = var.enable_dedicated_db ? 1 : 0
  server_id  = hcloud_server.database[0].id
  network_id = hcloud_network.main.id
  ip         = cidrhost(hcloud_network_subnet.servers.ip_range, 100)
}

`)
	}

	// Kubernetes/K3s specific configuration
	if isKubernetesDeployment(categorized) && config.HALevel.RequiresCluster() {
		buf.WriteString(generateK3sConfig(config, serverCount))
	}

	// Add placement group for HA (spread servers across different hosts)
	if config.HALevel.RequiresMultiServer() {
		buf.WriteString("# Placement group for HA (spread across hosts)\n")
		buf.WriteString(`resource "hcloud_placement_group" "app" {
  name = "${local.project_name}-spread"
  type = "spread"

  labels = local.common_labels
}

`)
		// Update server resource to use placement group
		buf.WriteString(`# Note: Add to hcloud_server.app resource:
# placement_group_id = hcloud_placement_group.app.id
`)
	}

	// Add variables for compute
	buf.WriteString("\n# Additional compute variables\n")
	buf.WriteString(`variable "db_server_type" {
  description = "Server type for dedicated database server"
  type        = string
  default     = "cx21"
}

variable "enable_dedicated_db" {
  description = "Enable dedicated database server"
  type        = bool
  default     = false
}
`)

	return buf.String()
}

// isKubernetesDeployment checks if the deployment includes Kubernetes resources.
func isKubernetesDeployment(categorized *CategorizedResults) bool {
	for _, result := range categorized.Compute {
		if result == nil {
			continue
		}
		resourceType := strings.ToLower(result.SourceResourceType)
		if strings.Contains(resourceType, "eks") ||
			strings.Contains(resourceType, "gke") ||
			strings.Contains(resourceType, "aks") ||
			strings.Contains(resourceType, "kubernetes") {
			return true
		}
	}
	return false
}

// generateK3sConfig generates K3s cluster configuration.
func generateK3sConfig(config *generator.TargetConfig, serverCount int) string {
	var buf bytes.Buffer

	buf.WriteString("\n# K3s Cluster Configuration\n")
	buf.WriteString(`# This deployment uses K3s for Kubernetes workloads
# K3s is installed via cloud-init on all app servers

# Master node token (generated)
resource "random_password" "k3s_token" {
  length  = 32
  special = false
}

# Store K3s token in a file for joining nodes
resource "local_file" "k3s_token" {
  content         = random_password.k3s_token.result
  filename        = "${path.module}/k3s-token.txt"
  file_permission = "0600"
}

`)

	if serverCount >= 3 {
		buf.WriteString(`# For 3+ nodes, first node is the initial master
# Other nodes join as both masters (for etcd) and workers

locals {
  k3s_master_ip = hcloud_server_network.app[0].ip
  k3s_token     = random_password.k3s_token.result
}
`)
	}

	return buf.String()
}

// GenerateServerTypeRecommendations generates recommendations for server types.
func GenerateServerTypeRecommendations(categorized *CategorizedResults) string {
	var buf bytes.Buffer

	buf.WriteString("# Server Type Recommendations\n")
	buf.WriteString("# Based on your workload analysis:\n\n")

	// Analyze compute requirements
	hasHeavyCompute := false
	hasDatabase := len(categorized.Database) > 0
	hasStorage := len(categorized.Storage) > 0

	for _, result := range categorized.Compute {
		if result != nil && result.SourceResourceType != "" {
			resourceType := strings.ToLower(result.SourceResourceType)
			if strings.Contains(resourceType, "large") ||
				strings.Contains(resourceType, "xlarge") ||
				strings.Contains(resourceType, "2xlarge") {
				hasHeavyCompute = true
			}
		}
	}

	if hasHeavyCompute {
		buf.WriteString("# Heavy compute detected - recommend cpx31 or higher\n")
		buf.WriteString("# server_type = \"cpx31\"  # 4 vCPU, 8GB RAM, 15.49 EUR/month\n\n")
	} else if hasDatabase {
		buf.WriteString("# Database workload detected - recommend cx21 or cpx21\n")
		buf.WriteString("# server_type = \"cpx21\"  # 3 vCPU, 4GB RAM, 8.39 EUR/month\n\n")
	} else if hasStorage {
		buf.WriteString("# Storage-focused workload - consider ARM for best value\n")
		buf.WriteString("# server_type = \"cax21\"  # 4 vCPU, 8GB RAM, 7.49 EUR/month (ARM)\n\n")
	} else {
		buf.WriteString("# General workload - cx21 is a good starting point\n")
		buf.WriteString("# server_type = \"cx21\"   # 2 vCPU, 4GB RAM, 5.18 EUR/month\n\n")
	}

	return buf.String()
}

// MapCloudVMToHetzner maps cloud VM types to Hetzner equivalents.
func MapCloudVMToHetzner(sourceType string) string {
	sourceType = strings.ToLower(sourceType)

	// AWS EC2 mapping
	if strings.HasPrefix(sourceType, "t2") || strings.HasPrefix(sourceType, "t3") {
		if strings.Contains(sourceType, "micro") || strings.Contains(sourceType, "nano") {
			return "cx11"
		}
		if strings.Contains(sourceType, "small") {
			return "cx21"
		}
		if strings.Contains(sourceType, "medium") {
			return "cpx21"
		}
		if strings.Contains(sourceType, "large") {
			return "cpx31"
		}
		if strings.Contains(sourceType, "xlarge") {
			return "cpx41"
		}
	}

	// GCP machine types
	if strings.Contains(sourceType, "e2-") || strings.Contains(sourceType, "n1-") || strings.Contains(sourceType, "n2-") {
		if strings.Contains(sourceType, "micro") || strings.Contains(sourceType, "small") {
			return "cx11"
		}
		if strings.Contains(sourceType, "medium") {
			return "cx21"
		}
		if strings.Contains(sourceType, "standard-2") {
			return "cpx21"
		}
		if strings.Contains(sourceType, "standard-4") {
			return "cpx31"
		}
		if strings.Contains(sourceType, "standard-8") {
			return "cpx41"
		}
	}

	// Azure VM sizes
	if strings.Contains(sourceType, "standard_b") || strings.Contains(sourceType, "standard_d") {
		if strings.Contains(sourceType, "1s") || strings.Contains(sourceType, "1") {
			return "cx11"
		}
		if strings.Contains(sourceType, "2s") || strings.Contains(sourceType, "2") {
			return "cx21"
		}
		if strings.Contains(sourceType, "4s") || strings.Contains(sourceType, "4") {
			return "cpx31"
		}
		if strings.Contains(sourceType, "8s") || strings.Contains(sourceType, "8") {
			return "cpx41"
		}
	}

	// Default mapping
	return "cx21"
}

// GetServerTypeForHALevel returns the recommended server type for an HA level.
func GetServerTypeForHALevel(haLevel target.HALevel) string {
	switch haLevel {
	case target.HALevelNone:
		return "cx21" // Minimum for production
	case target.HALevelBasic:
		return "cpx21" // Slightly more resources for monitoring
	case target.HALevelMultiServer:
		return "cpx21" // Balanced for multiple servers
	case target.HALevelCluster:
		return "cpx31" // More resources for cluster coordination
	default:
		return "cx21"
	}
}
