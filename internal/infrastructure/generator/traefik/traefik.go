// Package traefik generates Traefik configurations from mapping results.
package traefik

import (
	"bytes"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"time"

	"github.com/agnostech/agnostech/internal/domain/generator"
	"github.com/agnostech/agnostech/internal/domain/mapper"
)

// Config holds Traefik configuration options.
type Config struct {
	Email           string
	Domain          string
	DashboardUser   string
	DashboardPass   string
	EnableMetrics   bool
	EnableDashboard bool
	ACMEServer      string // Leave empty for Let's Encrypt production
}

// Generator generates Traefik configuration files.
type Generator struct {
	config *Config
}

// NewGenerator creates a new Traefik generator.
func NewGenerator(config *Config) *Generator {
	if config.ACMEServer == "" {
		config.ACMEServer = "https://acme-v02.api.letsencrypt.org/directory"
	}
	return &Generator{
		config: config,
	}
}

// Generate creates Traefik configuration files.
func (g *Generator) Generate(results []*mapper.MappingResult) (*generator.Output, error) {
	output := generator.NewOutput()

	// Generate static configuration
	staticConfig, err := g.generateStaticConfig()
	if err != nil {
		return nil, fmt.Errorf("failed to generate static config: %w", err)
	}
	output.AddFile("traefik/traefik.yml", []byte(staticConfig))

	// Generate dynamic configuration
	dynamicConfig, err := g.generateDynamicConfig(results)
	if err != nil {
		return nil, fmt.Errorf("failed to generate dynamic config: %w", err)
	}
	output.AddFile("traefik/dynamic/middlewares.yml", []byte(dynamicConfig))

	// Generate Traefik service for docker-compose
	traefikService, err := g.generateTraefikService()
	if err != nil {
		return nil, fmt.Errorf("failed to generate Traefik service: %w", err)
	}
	output.AddFile("traefik/docker-compose.traefik.yml", []byte(traefikService))

	output.AddMetadata("generated_at", time.Now().Format(time.RFC3339))
	output.AddMetadata("domain", g.config.Domain)

	return output, nil
}

// generateStaticConfig generates traefik.yml static configuration.
func (g *Generator) generateStaticConfig() (string, error) {
	var buf bytes.Buffer

	buf.WriteString("# Traefik Static Configuration\n")
	buf.WriteString(fmt.Sprintf("# Generated by CloudExit - %s\n\n", time.Now().Format(time.RFC3339)))

	// Entry points
	buf.WriteString("entryPoints:\n")
	buf.WriteString("  web:\n")
	buf.WriteString("    address: \":80\"\n")
	buf.WriteString("    http:\n")
	buf.WriteString("      redirections:\n")
	buf.WriteString("        entryPoint:\n")
	buf.WriteString("          to: websecure\n")
	buf.WriteString("          scheme: https\n\n")

	buf.WriteString("  websecure:\n")
	buf.WriteString("    address: \":443\"\n")
	buf.WriteString("    http:\n")
	buf.WriteString("      tls:\n")
	buf.WriteString("        certResolver: letsencrypt\n\n")

	// API and Dashboard
	if g.config.EnableDashboard {
		buf.WriteString("api:\n")
		buf.WriteString("  dashboard: true\n")
		buf.WriteString("  insecure: false\n\n")
	}

	// Providers
	buf.WriteString("providers:\n")
	buf.WriteString("  docker:\n")
	buf.WriteString("    endpoint: \"unix:///var/run/docker.sock\"\n")
	buf.WriteString("    exposedByDefault: false\n")
	buf.WriteString("    network: web\n")
	buf.WriteString("  file:\n")
	buf.WriteString("    directory: \"/etc/traefik/dynamic\"\n")
	buf.WriteString("    watch: true\n\n")

	// Metrics
	if g.config.EnableMetrics {
		buf.WriteString("metrics:\n")
		buf.WriteString("  prometheus:\n")
		buf.WriteString("    entryPoint: metrics\n")
		buf.WriteString("    addEntryPointsLabels: true\n")
		buf.WriteString("    addServicesLabels: true\n\n")

		buf.WriteString("# Metrics entry point\n")
		buf.WriteString("entryPoints:\n")
		buf.WriteString("  metrics:\n")
		buf.WriteString("    address: \":8082\"\n\n")
	}

	// Logging
	buf.WriteString("log:\n")
	buf.WriteString("  level: INFO\n")
	buf.WriteString("  filePath: \"/var/log/traefik/traefik.log\"\n\n")

	buf.WriteString("accessLog:\n")
	buf.WriteString("  filePath: \"/var/log/traefik/access.log\"\n\n")

	// ACME / Let's Encrypt
	if g.config.Email != "" {
		buf.WriteString("certificatesResolvers:\n")
		buf.WriteString("  letsencrypt:\n")
		buf.WriteString("    acme:\n")
		buf.WriteString(fmt.Sprintf("      email: %s\n", g.config.Email))
		buf.WriteString("      storage: /etc/traefik/acme/acme.json\n")
		buf.WriteString(fmt.Sprintf("      caServer: %s\n", g.config.ACMEServer))
		buf.WriteString("      httpChallenge:\n")
		buf.WriteString("        entryPoint: web\n\n")
	}

	return buf.String(), nil
}

// generateDynamicConfig generates dynamic middleware configuration.
func (g *Generator) generateDynamicConfig(results []*mapper.MappingResult) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("# Traefik Dynamic Configuration - Middlewares\n")
	buf.WriteString(fmt.Sprintf("# Generated by CloudExit - %s\n\n", time.Now().Format(time.RFC3339)))

	buf.WriteString("http:\n")
	buf.WriteString("  middlewares:\n")

	// Security headers middleware
	buf.WriteString("    security-headers:\n")
	buf.WriteString("      headers:\n")
	buf.WriteString("        customResponseHeaders:\n")
	buf.WriteString("          X-Frame-Options: \"SAMEORIGIN\"\n")
	buf.WriteString("          X-Content-Type-Options: \"nosniff\"\n")
	buf.WriteString("          X-XSS-Protection: \"1; mode=block\"\n")
	buf.WriteString("          Referrer-Policy: \"strict-origin-when-cross-origin\"\n")
	buf.WriteString("        sslRedirect: true\n")
	buf.WriteString("        stsSeconds: 31536000\n")
	buf.WriteString("        stsIncludeSubdomains: true\n")
	buf.WriteString("        stsPreload: true\n\n")

	// Compression middleware
	buf.WriteString("    compression:\n")
	buf.WriteString("      compress: {}\n\n")

	// Rate limit middleware
	buf.WriteString("    rate-limit:\n")
	buf.WriteString("      rateLimit:\n")
	buf.WriteString("        average: 100\n")
	buf.WriteString("        burst: 50\n\n")

	// Dashboard auth middleware
	if g.config.EnableDashboard && g.config.DashboardUser != "" && g.config.DashboardPass != "" {
		hashedPass := g.hashPassword(g.config.DashboardPass)
		buf.WriteString("    dashboard-auth:\n")
		buf.WriteString("      basicAuth:\n")
		buf.WriteString("        users:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s:%s\"\n\n", g.config.DashboardUser, hashedPass))
	}

	// CORS middleware (optional)
	buf.WriteString("    cors:\n")
	buf.WriteString("      headers:\n")
	buf.WriteString("        accessControlAllowMethods:\n")
	buf.WriteString("          - GET\n")
	buf.WriteString("          - POST\n")
	buf.WriteString("          - PUT\n")
	buf.WriteString("          - DELETE\n")
	buf.WriteString("          - OPTIONS\n")
	buf.WriteString("        accessControlAllowOriginList:\n")
	buf.WriteString("          - \"*\"\n")
	buf.WriteString("        accessControlMaxAge: 100\n")
	buf.WriteString("        addVaryHeader: true\n\n")

	// Add routers for services with Traefik labels
	buf.WriteString("  routers:\n")

	// Dashboard router
	if g.config.EnableDashboard {
		buf.WriteString("    dashboard:\n")
		buf.WriteString("      rule: \"Host(`traefik." + g.config.Domain + "`)\"\n")
		buf.WriteString("      service: api@internal\n")
		buf.WriteString("      entryPoints:\n")
		buf.WriteString("        - websecure\n")
		buf.WriteString("      tls:\n")
		buf.WriteString("        certResolver: letsencrypt\n")
		if g.config.DashboardUser != "" {
			buf.WriteString("      middlewares:\n")
			buf.WriteString("        - dashboard-auth\n")
		}
		buf.WriteString("\n")
	}

	return buf.String(), nil
}

// generateTraefikService generates a Docker Compose service definition for Traefik.
func (g *Generator) generateTraefikService() (string, error) {
	var buf bytes.Buffer

	buf.WriteString("# Traefik Service for Docker Compose\n")
	buf.WriteString(fmt.Sprintf("# Generated by CloudExit - %s\n\n", time.Now().Format(time.RFC3339)))

	buf.WriteString("version: \"3.8\"\n\n")
	buf.WriteString("services:\n")
	buf.WriteString("  traefik:\n")
	buf.WriteString("    image: traefik:v3.0\n")
	buf.WriteString("    restart: unless-stopped\n")
	buf.WriteString("    container_name: traefik\n")
	buf.WriteString("    ports:\n")
	buf.WriteString("      - \"80:80\"\n")
	buf.WriteString("      - \"443:443\"\n")
	if g.config.EnableMetrics {
		buf.WriteString("      - \"8082:8082\"  # Metrics\n")
	}
	buf.WriteString("    volumes:\n")
	buf.WriteString("      - /var/run/docker.sock:/var/run/docker.sock:ro\n")
	buf.WriteString("      - ./traefik/traefik.yml:/etc/traefik/traefik.yml:ro\n")
	buf.WriteString("      - ./traefik/dynamic:/etc/traefik/dynamic:ro\n")
	buf.WriteString("      - traefik-acme:/etc/traefik/acme\n")
	buf.WriteString("      - traefik-logs:/var/log/traefik\n")
	buf.WriteString("    networks:\n")
	buf.WriteString("      - web\n")
	buf.WriteString("      - internal\n")
	buf.WriteString("    environment:\n")
	buf.WriteString("      - TZ=UTC\n")
	buf.WriteString("    labels:\n")
	buf.WriteString("      - \"traefik.enable=true\"\n")

	if g.config.EnableDashboard {
		buf.WriteString("      # Dashboard\n")
		buf.WriteString(fmt.Sprintf("      - \"traefik.http.routers.dashboard.rule=Host(`traefik.%s`)\"\n", g.config.Domain))
		buf.WriteString("      - \"traefik.http.routers.dashboard.entrypoints=websecure\"\n")
		buf.WriteString("      - \"traefik.http.routers.dashboard.tls.certresolver=letsencrypt\"\n")
		buf.WriteString("      - \"traefik.http.routers.dashboard.service=api@internal\"\n")

		if g.config.DashboardUser != "" {
			buf.WriteString("      - \"traefik.http.routers.dashboard.middlewares=dashboard-auth\"\n")
		}
	}

	buf.WriteString("    healthcheck:\n")
	buf.WriteString("      test: [\"CMD\", \"traefik\", \"healthcheck\", \"--ping\"]\n")
	buf.WriteString("      interval: 10s\n")
	buf.WriteString("      timeout: 5s\n")
	buf.WriteString("      retries: 3\n")
	buf.WriteString("      start_period: 30s\n\n")

	buf.WriteString("networks:\n")
	buf.WriteString("  web:\n")
	buf.WriteString("    external: true\n")
	buf.WriteString("  internal:\n")
	buf.WriteString("    external: true\n\n")

	buf.WriteString("volumes:\n")
	buf.WriteString("  traefik-acme:\n")
	buf.WriteString("  traefik-logs:\n")

	return buf.String(), nil
}

// hashPassword creates a bcrypt hash of the password for basic auth.
// Note: This is a simple htpasswd-compatible hash using SHA256.
func (g *Generator) hashPassword(password string) string {
	// For htpasswd compatibility, we use SHA256
	// Format: {SHA}base64(sha256(password))
	hash := sha256.Sum256([]byte(password))
	encoded := base64.StdEncoding.EncodeToString(hash[:])
	return "{SHA}" + encoded
}

// GenerateTraefikLabels generates Traefik labels for a service.
func GenerateTraefikLabels(serviceName, domain, path string, port int) map[string]string {
	labels := make(map[string]string)

	// Enable Traefik
	labels["traefik.enable"] = "true"

	// Router configuration
	routerName := fmt.Sprintf("%s-router", serviceName)
	labels[fmt.Sprintf("traefik.http.routers.%s.rule", routerName)] = fmt.Sprintf("Host(`%s.%s`)", serviceName, domain)

	if path != "" {
		labels[fmt.Sprintf("traefik.http.routers.%s.rule", routerName)] = fmt.Sprintf("Host(`%s.%s`) && PathPrefix(`%s`)", serviceName, domain, path)
	}

	labels[fmt.Sprintf("traefik.http.routers.%s.entrypoints", routerName)] = "websecure"
	labels[fmt.Sprintf("traefik.http.routers.%s.tls.certresolver", routerName)] = "letsencrypt"

	// Service configuration
	if port > 0 {
		labels[fmt.Sprintf("traefik.http.services.%s.loadbalancer.server.port", serviceName)] = fmt.Sprintf("%d", port)
	}

	// Default middlewares
	labels[fmt.Sprintf("traefik.http.routers.%s.middlewares", routerName)] = "security-headers@file,compression@file"

	return labels
}

// MergeLabels merges Traefik labels with existing service labels.
func MergeLabels(existing, traefik map[string]string) map[string]string {
	merged := make(map[string]string)

	// Copy existing labels
	for k, v := range existing {
		merged[k] = v
	}

	// Add/override with Traefik labels
	for k, v := range traefik {
		merged[k] = v
	}

	return merged
}
