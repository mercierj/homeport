package scripts

import (
	"bytes"
	"fmt"
	"text/template"
	"time"

	"github.com/cloudexit/cloudexit/internal/domain/generator"
	"github.com/cloudexit/cloudexit/internal/domain/mapper"
)

// BackupGenerator generates backup scripts for data services.
type BackupGenerator struct {
	projectName   string
	retentionDays int
}

// NewBackupGenerator creates a new backup script generator.
func NewBackupGenerator(projectName string, retentionDays int) *BackupGenerator {
	if retentionDays <= 0 {
		retentionDays = 7 // Default retention
	}
	return &BackupGenerator{
		projectName:   projectName,
		retentionDays: retentionDays,
	}
}

// Generate creates backup scripts based on the services in mapping results.
func (g *BackupGenerator) Generate(results []*mapper.MappingResult) (*generator.Output, error) {
	output := generator.NewOutput()

	// Track which services need backups
	services := make(map[string]bool)
	for _, result := range results {
		// result.DockerService is now a single service, not a slice
		if result.DockerService != nil {
			// Check if service is a data service
			if g.isDataService(result.DockerService.Image) {
				services[result.DockerService.Name] = true
			}
		}
	}

	// Generate master backup script
	script, err := g.generateBackupScript(services)
	if err != nil {
		return nil, fmt.Errorf("failed to generate backup script: %w", err)
	}
	output.AddFile("scripts/backup.sh", []byte(script))

	// Generate restore script
	restoreScript, err := g.generateRestoreScript(services)
	if err != nil {
		return nil, fmt.Errorf("failed to generate restore script: %w", err)
	}
	output.AddFile("scripts/restore.sh", []byte(restoreScript))

	// Generate systemd timer for automated backups
	timerScript, err := g.generateSystemdTimer()
	if err != nil {
		return nil, fmt.Errorf("failed to generate systemd timer: %w", err)
	}
	output.AddFile("scripts/backup.timer", []byte(timerScript))

	// Generate systemd service
	serviceScript, err := g.generateSystemdService()
	if err != nil {
		return nil, fmt.Errorf("failed to generate systemd service: %w", err)
	}
	output.AddFile("scripts/backup.service", []byte(serviceScript))

	output.AddMetadata("generated_at", time.Now().Format(time.RFC3339))
	output.AddMetadata("retention_days", fmt.Sprintf("%d", g.retentionDays))

	return output, nil
}

// isDataService checks if a Docker image is a data service that needs backups.
func (g *BackupGenerator) isDataService(image string) bool {
	dataServices := []string{
		"postgres", "mysql", "mariadb", "mongo", "mongodb",
		"redis", "minio", "elasticsearch", "clickhouse",
		"cassandra", "cockroach", "timescale",
	}

	for _, svc := range dataServices {
		if contains(image, svc) {
			return true
		}
	}
	return false
}

// generateBackupScript generates the main backup script.
func (g *BackupGenerator) generateBackupScript(services map[string]bool) (string, error) {
	tmpl := `#!/bin/bash
# Automated Backup Script
# Generated by CloudExit - {{.Timestamp}}
# Project: {{.ProjectName}}

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
BACKUP_DIR="${BACKUP_DIR:-./backups}"
RETENTION_DAYS={{.RetentionDays}}
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
DATE=$(date +%Y-%m-%d)
LOG_FILE="$BACKUP_DIR/backup_${TIMESTAMP}.log"

# Create backup directories
mkdir -p "$BACKUP_DIR/postgres"
mkdir -p "$BACKUP_DIR/mysql"
mkdir -p "$BACKUP_DIR/mongodb"
mkdir -p "$BACKUP_DIR/redis"
mkdir -p "$BACKUP_DIR/minio"

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1" | tee -a "$LOG_FILE"
}

warning() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1" | tee -a "$LOG_FILE"
}

log "Starting backup process"

# Function to backup PostgreSQL
backup_postgres() {
    local container=$1
    local database=${2:-all}

    log "Backing up PostgreSQL: $container"

    if [ "$database" = "all" ]; then
        docker exec "$container" pg_dumpall -U postgres | \
            gzip > "$BACKUP_DIR/postgres/${container}_${TIMESTAMP}.sql.gz"
    else
        docker exec "$container" pg_dump -U postgres "$database" | \
            gzip > "$BACKUP_DIR/postgres/${container}_${database}_${TIMESTAMP}.sql.gz"
    fi

    if [ $? -eq 0 ]; then
        log "PostgreSQL backup completed: $container"
    else
        error "PostgreSQL backup failed: $container"
        return 1
    fi
}

# Function to backup MySQL/MariaDB
backup_mysql() {
    local container=$1
    local database=${2:-all}

    log "Backing up MySQL: $container"

    if [ "$database" = "all" ]; then
        docker exec "$container" mysqldump -u root --all-databases | \
            gzip > "$BACKUP_DIR/mysql/${container}_${TIMESTAMP}.sql.gz"
    else
        docker exec "$container" mysqldump -u root "$database" | \
            gzip > "$BACKUP_DIR/mysql/${container}_${database}_${TIMESTAMP}.sql.gz"
    fi

    if [ $? -eq 0 ]; then
        log "MySQL backup completed: $container"
    else
        error "MySQL backup failed: $container"
        return 1
    fi
}

# Function to backup MongoDB
backup_mongodb() {
    local container=$1

    log "Backing up MongoDB: $container"

    docker exec "$container" mongodump --archive | \
        gzip > "$BACKUP_DIR/mongodb/${container}_${TIMESTAMP}.archive.gz"

    if [ $? -eq 0 ]; then
        log "MongoDB backup completed: $container"
    else
        error "MongoDB backup failed: $container"
        return 1
    fi
}

# Function to backup Redis
backup_redis() {
    local container=$1

    log "Backing up Redis: $container"

    # Trigger Redis save
    docker exec "$container" redis-cli SAVE

    # Copy RDB file
    docker cp "$container:/data/dump.rdb" "$BACKUP_DIR/redis/${container}_${TIMESTAMP}.rdb"

    if [ $? -eq 0 ]; then
        log "Redis backup completed: $container"
    else
        error "Redis backup failed: $container"
        return 1
    fi
}

# Function to backup MinIO
backup_minio() {
    local container=$1

    log "Backing up MinIO: $container"

    # Export MinIO data using mc mirror
    if command -v mc >/dev/null 2>&1; then
        mc mirror "$container:/" "$BACKUP_DIR/minio/${container}_${TIMESTAMP}/"

        if [ $? -eq 0 ]; then
            log "MinIO backup completed: $container"
        else
            error "MinIO backup failed: $container"
            return 1
        fi
    else
        warning "MinIO Client (mc) not found, skipping MinIO backup"
    fi
}

# Backup all data services
{{range $service, $_ := .Services}}
{{if contains $service "postgres"}}
backup_postgres "{{$service}}" || true
{{else if contains $service "mysql"}}
backup_mysql "{{$service}}" || true
{{else if contains $service "mariadb"}}
backup_mysql "{{$service}}" || true
{{else if contains $service "mongo"}}
backup_mongodb "{{$service}}" || true
{{else if contains $service "redis"}}
backup_redis "{{$service}}" || true
{{else if contains $service "minio"}}
backup_minio "{{$service}}" || true
{{end}}
{{end}}

# Clean up old backups
log "Cleaning up backups older than $RETENTION_DAYS days"
find "$BACKUP_DIR" -type f -mtime +$RETENTION_DAYS -delete

log "Backup process completed"
log "Backup location: $BACKUP_DIR"

# Calculate backup size
BACKUP_SIZE=$(du -sh "$BACKUP_DIR" | cut -f1)
log "Total backup size: $BACKUP_SIZE"

# Optional: Upload to remote storage
if [ -n "$REMOTE_BACKUP_DESTINATION" ]; then
    log "Uploading backups to remote storage: $REMOTE_BACKUP_DESTINATION"
    rsync -avz --delete "$BACKUP_DIR/" "$REMOTE_BACKUP_DESTINATION/" || \
        error "Remote backup upload failed"
fi

log "All backups completed successfully"
`

	data := struct {
		Timestamp     string
		ProjectName   string
		RetentionDays int
		Services      map[string]bool
	}{
		Timestamp:     time.Now().Format(time.RFC3339),
		ProjectName:   g.projectName,
		RetentionDays: g.retentionDays,
		Services:      services,
	}

	// Custom template functions
	funcMap := template.FuncMap{
		"contains": contains,
	}

	t, err := template.New("backup").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// generateRestoreScript generates a script to restore from backups.
func (g *BackupGenerator) generateRestoreScript(services map[string]bool) (string, error) {
	tmpl := `#!/bin/bash
# Restore from Backup Script
# Generated by CloudExit - {{.Timestamp}}
# Project: {{.ProjectName}}

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
BACKUP_DIR="${BACKUP_DIR:-./backups}"

log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1"
}

# Function to restore PostgreSQL
restore_postgres() {
    local container=$1
    local backup_file=$2

    log "Restoring PostgreSQL: $container from $backup_file"

    if [[ "$backup_file" == *.gz ]]; then
        gunzip -c "$backup_file" | docker exec -i "$container" psql -U postgres
    else
        docker exec -i "$container" psql -U postgres < "$backup_file"
    fi

    if [ $? -eq 0 ]; then
        log "PostgreSQL restore completed: $container"
    else
        error "PostgreSQL restore failed: $container"
        return 1
    fi
}

# Function to restore MySQL/MariaDB
restore_mysql() {
    local container=$1
    local backup_file=$2

    log "Restoring MySQL: $container from $backup_file"

    if [[ "$backup_file" == *.gz ]]; then
        gunzip -c "$backup_file" | docker exec -i "$container" mysql -u root
    else
        docker exec -i "$container" mysql -u root < "$backup_file"
    fi

    if [ $? -eq 0 ]; then
        log "MySQL restore completed: $container"
    else
        error "MySQL restore failed: $container"
        return 1
    fi
}

# Function to restore MongoDB
restore_mongodb() {
    local container=$1
    local backup_file=$2

    log "Restoring MongoDB: $container from $backup_file"

    if [[ "$backup_file" == *.gz ]]; then
        gunzip -c "$backup_file" | docker exec -i "$container" mongorestore --archive
    else
        docker exec -i "$container" mongorestore --archive < "$backup_file"
    fi

    if [ $? -eq 0 ]; then
        log "MongoDB restore completed: $container"
    else
        error "MongoDB restore failed: $container"
        return 1
    fi
}

# Function to restore Redis
restore_redis() {
    local container=$1
    local backup_file=$2

    log "Restoring Redis: $container from $backup_file"

    # Stop container
    docker stop "$container"

    # Copy RDB file
    docker cp "$backup_file" "$container:/data/dump.rdb"

    # Start container
    docker start "$container"

    if [ $? -eq 0 ]; then
        log "Redis restore completed: $container"
    else
        error "Redis restore failed: $container"
        return 1
    fi
}

# Interactive restore
echo -e "${YELLOW}Available backup directories:${NC}"
ls -1 "$BACKUP_DIR"
echo ""

read -p "Enter service type (postgres/mysql/mongodb/redis): " service_type
read -p "Enter container name: " container_name
read -p "Enter backup file path: " backup_file

if [ ! -f "$backup_file" ]; then
    error "Backup file not found: $backup_file"
    exit 1
fi

case "$service_type" in
    postgres|postgresql)
        restore_postgres "$container_name" "$backup_file"
        ;;
    mysql|mariadb)
        restore_mysql "$container_name" "$backup_file"
        ;;
    mongo|mongodb)
        restore_mongodb "$container_name" "$backup_file"
        ;;
    redis)
        restore_redis "$container_name" "$backup_file"
        ;;
    *)
        error "Unsupported service type: $service_type"
        exit 1
        ;;
esac

log "Restore completed successfully"
`

	data := struct {
		Timestamp   string
		ProjectName string
	}{
		Timestamp:   time.Now().Format(time.RFC3339),
		ProjectName: g.projectName,
	}

	t, err := template.New("restore").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// generateSystemdTimer generates a systemd timer for automated backups.
func (g *BackupGenerator) generateSystemdTimer() (string, error) {
	return fmt.Sprintf(`[Unit]
Description=CloudExit Backup Timer
Requires=backup.service

[Timer]
OnCalendar=daily
OnCalendar=*-*-* 02:00:00
Persistent=true

[Install]
WantedBy=timers.target
`), nil
}

// generateSystemdService generates a systemd service for backups.
func (g *BackupGenerator) generateSystemdService() (string, error) {
	return fmt.Sprintf(`[Unit]
Description=CloudExit Backup Service
After=docker.service
Requires=docker.service

[Service]
Type=oneshot
ExecStart=/bin/bash /path/to/scripts/backup.sh
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
`), nil
}

// contains checks if a string contains a substring.
func contains(s, substr string) bool {
	return bytes.Contains([]byte(s), []byte(substr))
}
