// Package scaleway generates Terraform configurations for Scaleway cloud platform.
package scaleway

import (
	"bytes"
	"fmt"
	"strings"
	"time"

	"github.com/homeport/homeport/internal/domain/generator"
	"github.com/homeport/homeport/internal/domain/mapper"
)

// GenerateDatabaseTF generates Terraform configuration for database resources.
// This includes Managed PostgreSQL/MySQL (RDB) and Redis.
func GenerateDatabaseTF(databases, caches []*mapper.MappingResult, config *generator.TargetConfig, region string) string {
	var buf bytes.Buffer

	buf.WriteString("# Scaleway Database Resources\n")
	buf.WriteString(fmt.Sprintf("# Generated by Homeport - %s\n\n", time.Now().Format(time.RFC3339)))

	// Generate RDB (PostgreSQL/MySQL) instances
	if len(databases) > 0 {
		buf.WriteString("# ============================================\n")
		buf.WriteString("# Managed Databases (RDB)\n")
		buf.WriteString("# ============================================\n\n")

		for i, r := range databases {
			name := SanitizeTFName(r.SourceResourceName)
			if name == "" {
				name = fmt.Sprintf("db_%d", i)
			}

			displayName := SanitizeName(r.SourceResourceName)
			if displayName == "" {
				displayName = fmt.Sprintf("db-%d", i)
			}

			// Determine database engine from source
			dbEngine := "PostgreSQL-15"
			if strings.Contains(strings.ToLower(r.SourceResourceType), "mysql") {
				dbEngine = "MySQL-8"
			} else if strings.Contains(strings.ToLower(r.SourceResourceType), "maria") {
				dbEngine = "MySQL-8" // MariaDB not available, use MySQL
			}

			buf.WriteString(fmt.Sprintf("# Database: %s (from %s)\n", r.SourceResourceName, r.SourceResourceType))

			// Main RDB instance
			buf.WriteString(fmt.Sprintf(`resource "scaleway_rdb_instance" "%s" {
  name           = "${local.project_name}-%s"
  node_type      = var.db_node_type
  engine         = "%s"
  is_ha_cluster  = var.db_ha_enabled
  disable_backup = false
  region         = var.scw_region

  # Backup configuration
  backup_schedule_frequency = 24      # Hours between backups
  backup_schedule_retention = 7       # Days to keep backups
  backup_same_region        = false   # Store in different region for DR

  # Volume configuration
  volume_type       = "bssd"
  volume_size_in_gb = 20

  # Private network
  private_network {
    pn_id  = scaleway_vpc_private_network.main.id
    ip_net = "10.0.1.0/24"
  }

  # Settings
  settings = {
    max_connections = "200"
  }

  tags = local.common_tags

  lifecycle {
    prevent_destroy = false  # Set to true in production
  }
}

`, name, displayName, dbEngine))

			// Create database
			buf.WriteString(fmt.Sprintf(`resource "scaleway_rdb_database" "%s" {
  instance_id = scaleway_rdb_instance.%s.id
  name        = "%s"
}

`, name, name, displayName))

			// Create user
			buf.WriteString(fmt.Sprintf(`resource "scaleway_rdb_user" "%s" {
  instance_id = scaleway_rdb_instance.%s.id
  name        = var.db_username
  password    = var.db_password
  is_admin    = true
}

`, name, name))

			// Read replica for HA
			if config.HALevel.RequiresMultiServer() {
				buf.WriteString(fmt.Sprintf(`# Read replica for %s
resource "scaleway_rdb_read_replica" "%s_replica" {
  instance_id = scaleway_rdb_instance.%s.id
  region      = var.scw_region

  # Same availability zone for low latency
  same_zone = true

  # Direct access configuration
  direct_access {}

  # Private network (optional, can use same VPC)
  private_network {
    private_network_id = scaleway_vpc_private_network.main.id
    service_ip         = "10.0.1.100/24"
  }
}

`, name, name, name))
			}

			// Database ACL for security
			buf.WriteString(fmt.Sprintf(`resource "scaleway_rdb_acl" "%s" {
  instance_id = scaleway_rdb_instance.%s.id

  # Allow access from VPC
  acl_rules {
    ip          = "10.0.0.0/16"
    description = "VPC access"
  }

  # Note: Add specific IPs for external access if needed
}

`, name, name))
		}
	}

	// Generate Redis clusters
	if len(caches) > 0 {
		buf.WriteString("# ============================================\n")
		buf.WriteString("# Redis Clusters\n")
		buf.WriteString("# ============================================\n\n")

		for i, r := range caches {
			name := SanitizeTFName(r.SourceResourceName)
			if name == "" {
				name = fmt.Sprintf("redis_%d", i)
			}

			displayName := SanitizeName(r.SourceResourceName)
			if displayName == "" {
				displayName = fmt.Sprintf("redis-%d", i)
			}

			buf.WriteString(fmt.Sprintf("# Redis: %s (from %s)\n", r.SourceResourceName, r.SourceResourceType))

			// Determine cluster size based on source
			clusterSize := GetRedisClusterSize(config.HALevel)

			buf.WriteString(fmt.Sprintf(`resource "scaleway_redis_cluster" "%s" {
  name         = "${local.project_name}-%s"
  version      = var.redis_version
  node_type    = var.redis_node_type
  cluster_size = var.redis_cluster_size
  zone         = var.scw_zone

  # TLS configuration
  tls_enabled = true

  # User and ACL
  user_name = "default"
  password  = var.db_password  # Reuse db_password or create separate var

  # Public network access
  public_network {
    # Will get assigned IPs
  }

  # Private network
  private_network {
    id = scaleway_vpc_private_network.main.id
  }

  # Settings based on cluster size
  settings = {
    maxmemory_policy = "allkeys-lru"
    tcp_keepalive    = "300"
  }

  tags = local.common_tags
}

`, name, displayName))

			// ACL rules for Redis
			buf.WriteString(fmt.Sprintf(`resource "scaleway_redis_cluster_acl_rules" "%s" {
  cluster_id = scaleway_redis_cluster.%s.id

  acl_rules {
    ip_cidr     = "10.0.0.0/16"
    description = "VPC access"
  }
}

`, name, name))

			// For cluster mode (HA)
			if clusterSize > 1 {
				buf.WriteString(fmt.Sprintf(`# Redis cluster %s is configured with %d nodes for HA
# Endpoints will be available via public_network and private_network

`, name, clusterSize))
			}
		}
	}

	// Add database connection helper outputs
	if len(databases) > 0 || len(caches) > 0 {
		buf.WriteString("# ============================================\n")
		buf.WriteString("# Connection String Helpers\n")
		buf.WriteString("# ============================================\n\n")

		for _, r := range databases {
			name := SanitizeTFName(r.SourceResourceName)
			if name == "" {
				continue
			}

			buf.WriteString(fmt.Sprintf(`output "db_%s_connection_string" {
  description = "Database connection string for %s"
  value       = "postgresql://${var.db_username}:${var.db_password}@${scaleway_rdb_instance.%s.endpoint_ip}:${scaleway_rdb_instance.%s.endpoint_port}/%s"
  sensitive   = true
}

`, name, name, name, name, name))
		}

		for _, r := range caches {
			name := SanitizeTFName(r.SourceResourceName)
			if name == "" {
				continue
			}

			buf.WriteString(fmt.Sprintf(`output "redis_%s_connection_string" {
  description = "Redis connection string for %s"
  value       = "rediss://default:${var.db_password}@${join(",", scaleway_redis_cluster.%s.public_network[0].ips)}:6379"
  sensitive   = true
}

`, name, name, name))
		}
	}

	return buf.String()
}
