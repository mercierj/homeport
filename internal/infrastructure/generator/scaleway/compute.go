// Package scaleway generates Terraform configurations for Scaleway cloud platform.
package scaleway

import (
	"bytes"
	"fmt"
	"strings"
	"time"

	"github.com/homeport/homeport/internal/domain/generator"
	"github.com/homeport/homeport/internal/domain/mapper"
	"github.com/homeport/homeport/internal/domain/target"
)

// GenerateComputeTF generates Terraform configuration for compute resources.
// This includes Scaleway Instances and Kapsule (Kubernetes) clusters.
func GenerateComputeTF(compute, kubernetes []*mapper.MappingResult, config *generator.TargetConfig, zone string) string {
	var buf bytes.Buffer

	buf.WriteString("# Scaleway Compute Resources\n")
	buf.WriteString(fmt.Sprintf("# Generated by Homeport - %s\n\n", time.Now().Format(time.RFC3339)))

	// Generate SSH key resource if instances are present
	if len(compute) > 0 {
		buf.WriteString("# ============================================\n")
		buf.WriteString("# SSH Key\n")
		buf.WriteString("# ============================================\n\n")

		buf.WriteString(`resource "scaleway_account_ssh_key" "main" {
  count      = var.ssh_public_key != "" ? 1 : 0
  name       = "${local.project_name}-ssh-key"
  public_key = var.ssh_public_key
}

`)
	}

	// Generate instances
	if len(compute) > 0 {
		buf.WriteString("# ============================================\n")
		buf.WriteString("# Instances\n")
		buf.WriteString("# ============================================\n\n")

		for i, r := range compute {
			name := SanitizeTFName(r.SourceResourceName)
			if name == "" {
				name = fmt.Sprintf("instance_%d", i)
			}

			displayName := SanitizeName(r.SourceResourceName)
			if displayName == "" {
				displayName = fmt.Sprintf("instance-%d", i)
			}

			buf.WriteString(fmt.Sprintf("# Instance: %s (from %s)\n", r.SourceResourceName, r.SourceResourceType))

			// IP address resource
			buf.WriteString(fmt.Sprintf(`resource "scaleway_instance_ip" "%s" {
  zone = var.scw_zone
}

`, name))

			// Security group
			buf.WriteString(fmt.Sprintf(`resource "scaleway_instance_security_group" "%s" {
  name                    = "${local.project_name}-%s-sg"
  zone                    = var.scw_zone
  inbound_default_policy  = "drop"
  outbound_default_policy = "accept"

  # SSH access
  inbound_rule {
    action   = "accept"
    protocol = "TCP"
    port     = 22
  }

  # HTTP
  inbound_rule {
    action   = "accept"
    protocol = "TCP"
    port     = 80
  }

  # HTTPS
  inbound_rule {
    action   = "accept"
    protocol = "TCP"
    port     = 443
  }

  # ICMP (ping)
  inbound_rule {
    action   = "accept"
    protocol = "ICMP"
  }

  tags = local.common_tags
}

`, name, displayName))

			// Instance resource
			buf.WriteString(fmt.Sprintf(`resource "scaleway_instance_server" "%s" {
  name              = "${local.project_name}-%s"
  type              = var.instance_type
  image             = var.instance_image
  zone              = var.scw_zone
  ip_id             = scaleway_instance_ip.%s.id
  security_group_id = scaleway_instance_security_group.%s.id

  root_volume {
    size_in_gb            = 20
    volume_type           = "b_ssd"
    delete_on_termination = true
  }

  # Attach to VPC
  private_network {
    pn_id = scaleway_vpc_private_network.main.id
  }

  # User data for cloud-init
  user_data = {
    cloud-init = <<-EOF
      #cloud-config
      package_update: true
      package_upgrade: true
      packages:
        - docker.io
        - docker-compose
      runcmd:
        - systemctl enable docker
        - systemctl start docker
    EOF
  }

  tags = local.common_tags

  lifecycle {
    ignore_changes = [user_data]
  }
}

`, name, displayName, name, name))
		}

		// HA: Additional instances if needed
		if config.HALevel.RequiresMultiServer() {
			instanceCount := getHAInstanceCount(config.HALevel)
			if instanceCount > 1 {
				buf.WriteString("# ============================================\n")
				buf.WriteString("# Additional HA Instances\n")
				buf.WriteString("# ============================================\n\n")

				buf.WriteString(fmt.Sprintf(`resource "scaleway_instance_ip" "ha_nodes" {
  count = %d
  zone  = var.scw_zone
}

resource "scaleway_instance_security_group" "ha_nodes" {
  name                    = "${local.project_name}-ha-sg"
  zone                    = var.scw_zone
  inbound_default_policy  = "drop"
  outbound_default_policy = "accept"

  inbound_rule {
    action   = "accept"
    protocol = "TCP"
    port     = 22
  }

  inbound_rule {
    action   = "accept"
    protocol = "TCP"
    port     = 80
  }

  inbound_rule {
    action   = "accept"
    protocol = "TCP"
    port     = 443
  }

  inbound_rule {
    action   = "accept"
    protocol = "ICMP"
  }

  tags = local.common_tags
}

resource "scaleway_instance_server" "ha_nodes" {
  count             = %d
  name              = "${local.project_name}-ha-${count.index}"
  type              = var.instance_type
  image             = var.instance_image
  zone              = var.scw_zone
  ip_id             = scaleway_instance_ip.ha_nodes[count.index].id
  security_group_id = scaleway_instance_security_group.ha_nodes.id

  root_volume {
    size_in_gb            = 20
    volume_type           = "b_ssd"
    delete_on_termination = true
  }

  private_network {
    pn_id = scaleway_vpc_private_network.main.id
  }

  user_data = {
    cloud-init = <<-EOF
      #cloud-config
      package_update: true
      package_upgrade: true
      packages:
        - docker.io
        - docker-compose
      runcmd:
        - systemctl enable docker
        - systemctl start docker
    EOF
  }

  tags = concat(local.common_tags, ["ha-node"])

  lifecycle {
    ignore_changes = [user_data]
  }
}

`, instanceCount-1, instanceCount-1))
			}
		}
	}

	// Generate Kubernetes (Kapsule) clusters
	if len(kubernetes) > 0 {
		buf.WriteString("# ============================================\n")
		buf.WriteString("# Kubernetes (Kapsule) Clusters\n")
		buf.WriteString("# ============================================\n\n")

		for i, r := range kubernetes {
			name := SanitizeTFName(r.SourceResourceName)
			if name == "" {
				name = fmt.Sprintf("k8s_%d", i)
			}

			displayName := SanitizeName(r.SourceResourceName)
			if displayName == "" {
				displayName = fmt.Sprintf("k8s-%d", i)
			}

			buf.WriteString(fmt.Sprintf("# Kubernetes Cluster: %s (from %s)\n", r.SourceResourceName, r.SourceResourceType))

			// CNI type based on source
			cniType := "cilium"
			if strings.Contains(strings.ToLower(r.SourceResourceType), "eks") {
				cniType = "cilium" // AWS-like
			} else if strings.Contains(strings.ToLower(r.SourceResourceType), "gke") {
				cniType = "cilium" // GCP-like
			}

			// Autoscaling enabled for HA
			autoscaleEnabled := config.HALevel.RequiresMultiServer()

			buf.WriteString(fmt.Sprintf(`resource "scaleway_k8s_cluster" "%s" {
  name                        = "${local.project_name}-%s"
  version                     = var.k8s_version
  cni                         = "%s"
  delete_additional_resources = true
  region                      = var.scw_region

  # Private network integration
  private_network_id = scaleway_vpc_private_network.main.id

  # Auto-upgrade settings
  auto_upgrade {
    enable                        = true
    maintenance_window_start_hour = 3
    maintenance_window_day        = "sunday"
  }

  # Admission plugins
  admission_plugins = ["PodSecurityPolicy"]

  # Feature gates
  feature_gates = []

  tags = local.common_tags
}

`, name, displayName, cniType))

			// Node pool
			buf.WriteString(fmt.Sprintf(`resource "scaleway_k8s_pool" "%s_default" {
  cluster_id          = scaleway_k8s_cluster.%s.id
  name                = "default"
  node_type           = var.k8s_node_type
  size                = var.k8s_node_count
  autoscaling         = var.k8s_autoscale
  min_size            = var.k8s_min_nodes
  max_size            = var.k8s_max_nodes
  autohealing         = true
  container_runtime   = "containerd"
  wait_for_pool_ready = true
  zone                = var.scw_zone

  # Upgrade policy
  upgrade_policy {
    max_surge       = 1
    max_unavailable = 0
  }

  tags = local.common_tags
}

`, name, name))

			// Additional node pool for HA clusters
			if autoscaleEnabled {
				buf.WriteString(fmt.Sprintf(`# Additional pool for workloads (HA)
resource "scaleway_k8s_pool" "%s_workloads" {
  cluster_id          = scaleway_k8s_cluster.%s.id
  name                = "workloads"
  node_type           = var.k8s_node_type
  size                = var.k8s_node_count
  autoscaling         = true
  min_size            = 1
  max_size            = var.k8s_max_nodes
  autohealing         = true
  container_runtime   = "containerd"
  wait_for_pool_ready = true
  zone                = var.scw_zone

  upgrade_policy {
    max_surge       = 1
    max_unavailable = 0
  }

  # Node labels and taints
  placement_group_id = null

  tags = concat(local.common_tags, ["workloads"])
}

`, name, name))
			}
		}
	}

	return buf.String()
}

// getHAInstanceCount returns the number of instances for HA.
func getHAInstanceCount(level target.HALevel) int {
	switch level {
	case target.HALevelNone, target.HALevelBasic:
		return 1
	case target.HALevelMultiServer:
		return 2
	case target.HALevelCluster:
		return 3
	default:
		return 2 // Default for multi-server
	}
}

// For the config level
func getHAInstanceCountFromLevel(level string) int {
	switch level {
	case "multi-server":
		return 2
	case "cluster":
		return 3
	default:
		return 1
	}
}
