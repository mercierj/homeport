// Package docs generates documentation for the migrated infrastructure.
package docs

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/homeport/homeport/internal/domain/generator"
	"github.com/homeport/homeport/internal/domain/mapper"
)

// Generator generates documentation files.
type Generator struct {
	projectName string
	domain      string
}

// NewGenerator creates a new documentation generator.
func NewGenerator(projectName, domain string) *Generator {
	return &Generator{
		projectName: projectName,
		domain:      domain,
	}
}

// Generate creates documentation files.
func (g *Generator) Generate(results []*mapper.MappingResult) (*generator.Output, error) {
	output := generator.NewOutput()

	// Generate README.md
	readme, err := g.generateReadme(results)
	if err != nil {
		return nil, fmt.Errorf("failed to generate README: %w", err)
	}
	output.AddFile("README.md", []byte(readme))

	// Generate ARCHITECTURE.md
	architecture, err := g.generateArchitecture(results)
	if err != nil {
		return nil, fmt.Errorf("failed to generate ARCHITECTURE: %w", err)
	}
	output.AddFile("ARCHITECTURE.md", []byte(architecture))

	// Generate MIGRATION.md
	migration, err := g.generateMigration(results)
	if err != nil {
		return nil, fmt.Errorf("failed to generate MIGRATION: %w", err)
	}
	output.AddFile("MIGRATION.md", []byte(migration))

	// Generate .env.example
	envExample, err := g.generateEnvExample(results)
	if err != nil {
		return nil, fmt.Errorf("failed to generate .env.example: %w", err)
	}
	output.AddFile(".env.example", []byte(envExample))

	output.AddMetadata("generated_at", time.Now().Format(time.RFC3339))
	output.AddMetadata("project", g.projectName)

	return output, nil
}

// generateReadme generates the main README.md file.
func (g *Generator) generateReadme(results []*mapper.MappingResult) (string, error) {
	tmpl := `# {{.ProjectName}}

> Self-hosted infrastructure migrated from AWS

**Generated by Homeport** - {{.Timestamp}}

## Overview

This project contains a self-hosted infrastructure stack that replaces your AWS services with open-source alternatives. All services are containerized using Docker Compose and can be deployed on any server or cloud provider.

## Services

{{range .Services}}
### {{.Name}}

- **Image:** {{.Image}}
- **Purpose:** {{.Description}}
{{if .Ports}}- **Ports:** {{.Ports}}{{end}}
{{if .URL}}- **URL:** {{.URL}}{{end}}

{{end}}

## Quick Start

### Prerequisites

- Docker Engine 20.10+
- Docker Compose 2.0+
- At least {{.MinRAM}}GB RAM
- At least {{.MinDisk}}GB disk space

### Installation

1. Clone this repository:
   ` + "```bash\n   git clone <repository-url>\n   cd {{.ProjectName}}\n   ```" + `

2. Copy and configure environment variables:
   ` + "```bash\n   cp .env.example .env\n   # Edit .env with your configuration\n   nano .env\n   ```" + `

3. Start the services:
   ` + "```bash\n   docker-compose up -d\n   ```" + `

4. Check service status:
   ` + "```bash\n   docker-compose ps\n   ```" + `

## Configuration

All configuration is done through environment variables in the ` + "`.env`" + ` file. See ` + "`.env.example`" + ` for all available options.

### SSL/TLS Certificates

This setup uses Traefik with Let's Encrypt for automatic SSL certificates. Make sure to:

1. Point your domain DNS to your server's IP address
2. Configure your email in ` + "`.env`" + ` for Let's Encrypt notifications
3. Ensure ports 80 and 443 are accessible from the internet

## Data Migration

To migrate your data from AWS to this self-hosted setup:

1. Review the migration guide: ` + "`MIGRATION.md`" + `
2. Run the migration scripts in the ` + "`scripts/`" + ` directory
3. Verify all data has been migrated correctly
4. Update your application configuration to point to the new services

See [MIGRATION.md](MIGRATION.md) for detailed instructions.

## Backup and Restore

### Backup

Run the backup script to create backups of all data services:

` + "```bash\n./scripts/backup.sh\n```" + `

Backups are stored in ` + "`./backups/`" + ` by default.

### Restore

To restore from a backup:

` + "```bash\n./scripts/restore.sh\n```" + `

Follow the interactive prompts to select the service and backup to restore.

## Monitoring

- **Traefik Dashboard:** https://traefik.{{.Domain}}
- **Metrics:** Exposed on port 8082 (Prometheus format)

## Troubleshooting

### Services won't start

` + "```bash\n# Check logs\ndocker-compose logs [service-name]\n\n# Restart a service\ndocker-compose restart [service-name]\n```" + `

### SSL certificate issues

` + "```bash\n# Check Traefik logs\ndocker-compose logs traefik\n\n# Verify DNS is pointing to your server\nnslookup {{.Domain}}\n```" + `

### Out of disk space

` + "```bash\n# Clean up old Docker images and volumes\ndocker system prune -a --volumes\n\n# Check disk usage\ndf -h\ndu -sh ./backups\n```" + `

## Maintenance

### Updates

To update services to the latest versions:

` + "```bash\n# Pull latest images\ndocker-compose pull\n\n# Restart services\ndocker-compose up -d\n```" + `

### Scaling

To scale a service:

` + "```bash\ndocker-compose up -d --scale [service-name]=[count]\n```" + `

## Architecture

See [ARCHITECTURE.md](ARCHITECTURE.md) for a detailed overview of the system architecture.

## Security

- All services run on an internal network by default
- Only Traefik is exposed to the internet
- SSL/TLS is enforced for all public-facing services
- Sensitive data is stored in environment variables (not in version control)

### Security Best Practices

1. Change all default passwords in ` + "`.env`" + `
2. Keep Docker and all images up to date
3. Regularly backup your data
4. Monitor logs for suspicious activity
5. Use strong passwords and enable 2FA where possible

## Support

For issues and questions:

1. Check the [Troubleshooting](#troubleshooting) section
2. Review service logs: ` + "`docker-compose logs [service-name]`" + `
3. Consult the upstream documentation for each service

## License

This infrastructure configuration is generated by Homeport.
Individual services are licensed under their respective licenses.

---

**Note:** This infrastructure was automatically generated from your AWS setup. Please review all configurations and customize as needed for your specific requirements.
`

	// Collect service information
	services := []ServiceInfo{}
	envVars := make(map[string]bool)

	for _, result := range results {
		// result.DockerService is now a single service, not a slice
		if result.DockerService != nil {
			svc := result.DockerService
			info := ServiceInfo{
				Name:        svc.Name,
				Image:       svc.Image,
				Description: g.getServiceDescription(svc.Image),
				Ports:       strings.Join(svc.Ports, ", "),
			}

			// Generate URL if service has Traefik labels
			for key, value := range svc.Labels {
				if strings.HasPrefix(key, "traefik.http.routers.") && strings.HasSuffix(key, ".rule") {
					if strings.Contains(value, "Host(") {
						// Extract host from rule
						info.URL = extractHostFromRule(value)
					}
				}
			}

			services = append(services, info)

			// Collect environment variables
			for key := range svc.Environment {
				envVars[key] = true
			}
		}
	}

	data := struct {
		ProjectName string
		Timestamp   string
		Services    []ServiceInfo
		Domain      string
		MinRAM      int
		MinDisk     int
	}{
		ProjectName: g.projectName,
		Timestamp:   time.Now().Format(time.RFC3339),
		Services:    services,
		Domain:      g.domain,
		MinRAM:      g.calculateMinRAM(results),
		MinDisk:     g.calculateMinDisk(results),
	}

	t, err := template.New("readme").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// generateArchitecture generates the ARCHITECTURE.md file.
func (g *Generator) generateArchitecture(results []*mapper.MappingResult) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("# Architecture Overview\n\n")
	buf.WriteString(fmt.Sprintf("**Generated by Homeport** - %s\n\n", time.Now().Format(time.RFC3339)))

	buf.WriteString("## System Architecture\n\n")
	buf.WriteString("This document describes the architecture of the self-hosted infrastructure.\n\n")

	buf.WriteString("## Network Architecture\n\n")
	buf.WriteString("The system uses two Docker networks:\n\n")
	buf.WriteString("- **web**: Public-facing network for services exposed to the internet\n")
	buf.WriteString("- **internal**: Private network for internal service communication\n\n")

	buf.WriteString("```\n")
	buf.WriteString("Internet\n")
	buf.WriteString("   |\n")
	buf.WriteString("   v\n")
	buf.WriteString("Traefik (Reverse Proxy)\n")
	buf.WriteString("   |\n")
	buf.WriteString("   +-- web network --+\n")
	buf.WriteString("   |                 |\n")
	buf.WriteString("   v                 v\n")
	buf.WriteString("Application      Internal Services\n")
	buf.WriteString("Services         (Database, Cache, etc.)\n")
	buf.WriteString("   |                 |\n")
	buf.WriteString("   +-- internal network --+\n")
	buf.WriteString("```\n\n")

	buf.WriteString("## Services\n\n")

	// Group services by category
	categories := make(map[string][]*mapper.DockerService)
	for _, result := range results {
		// result.DockerService is now a single service, not a slice
		if result.DockerService != nil {
			category := g.categorizeService(result.DockerService.Image)
			categories[category] = append(categories[category], result.DockerService)
		}
	}

	// Sort categories
	categoryNames := make([]string, 0, len(categories))
	for cat := range categories {
		categoryNames = append(categoryNames, cat)
	}
	sort.Strings(categoryNames)

	for _, category := range categoryNames {
		buf.WriteString(fmt.Sprintf("### %s\n\n", category))

		for _, svc := range categories[category] {
			buf.WriteString(fmt.Sprintf("#### %s\n\n", svc.Name))
			buf.WriteString(fmt.Sprintf("- **Image:** %s\n", svc.Image))
			buf.WriteString(fmt.Sprintf("- **Networks:** %s\n", strings.Join(svc.Networks, ", ")))

			if len(svc.DependsOn) > 0 {
				buf.WriteString(fmt.Sprintf("- **Dependencies:** %s\n", strings.Join(svc.DependsOn, ", ")))
			}

			if len(svc.Volumes) > 0 {
				buf.WriteString("- **Volumes:**\n")
				for _, vol := range svc.Volumes {
					buf.WriteString(fmt.Sprintf("  - %s\n", vol))
				}
			}

			buf.WriteString("\n")
		}
	}

	buf.WriteString("## Data Persistence\n\n")
	buf.WriteString("The following services have persistent data:\n\n")

	for _, result := range results {
		// result.DockerService is now a single service, not a slice
		if result.DockerService != nil {
			svc := result.DockerService
			if len(svc.Volumes) > 0 {
				buf.WriteString(fmt.Sprintf("- **%s**: ", svc.Name))
				volumeCount := 0
				for _, vol := range svc.Volumes {
					if !strings.Contains(vol, ":ro") {
						volumeCount++
					}
				}
				buf.WriteString(fmt.Sprintf("%d persistent volume(s)\n", volumeCount))
			}
		}
	}

	buf.WriteString("\n## Security\n\n")
	buf.WriteString("### Network Security\n\n")
	buf.WriteString("- Services are isolated on internal networks\n")
	buf.WriteString("- Only Traefik is exposed to the public internet\n")
	buf.WriteString("- All internal communication happens over the internal network\n\n")

	buf.WriteString("### SSL/TLS\n\n")
	buf.WriteString("- Automatic SSL certificates via Let's Encrypt\n")
	buf.WriteString("- HTTP to HTTPS redirection enforced\n")
	buf.WriteString("- HSTS headers enabled\n\n")

	buf.WriteString("## Scalability\n\n")
	buf.WriteString("Services can be scaled horizontally using Docker Compose:\n\n")
	buf.WriteString("```bash\n")
	buf.WriteString("docker-compose up -d --scale service-name=3\n")
	buf.WriteString("```\n\n")

	buf.WriteString("Traefik will automatically load balance traffic across replicas.\n\n")

	return buf.String(), nil
}

// generateMigration generates the MIGRATION.md file.
func (g *Generator) generateMigration(results []*mapper.MappingResult) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("# Migration Guide\n\n")
	buf.WriteString(fmt.Sprintf("**Generated by Homeport** - %s\n\n", time.Now().Format(time.RFC3339)))

	buf.WriteString("This guide walks you through migrating your AWS infrastructure to self-hosted services.\n\n")

	buf.WriteString("## Prerequisites\n\n")
	buf.WriteString("Before starting the migration:\n\n")
	buf.WriteString("1. Review the README.md for system requirements\n")
	buf.WriteString("2. Ensure you have AWS credentials configured\n")
	buf.WriteString("3. Install required tools: AWS CLI, Docker, Docker Compose\n")
	buf.WriteString("4. Backup all AWS data before migration\n\n")

	buf.WriteString("## Migration Steps\n\n")

	// Collect manual steps
	manualSteps := []string{}
	for _, result := range results {
		manualSteps = append(manualSteps, result.ManualSteps...)
	}

	if len(manualSteps) > 0 {
		buf.WriteString("### Manual Steps Required\n\n")
		for i, step := range manualSteps {
			buf.WriteString(fmt.Sprintf("%d. %s\n", i+1, step))
		}
		buf.WriteString("\n")
	}

	buf.WriteString("### 1. Deploy Self-Hosted Infrastructure\n\n")
	buf.WriteString("```bash\n")
	buf.WriteString("# Configure environment variables\n")
	buf.WriteString("cp .env.example .env\n")
	buf.WriteString("nano .env  # Edit with your configuration\n\n")
	buf.WriteString("# Start services\n")
	buf.WriteString("docker-compose up -d\n\n")
	buf.WriteString("# Verify services are running\n")
	buf.WriteString("docker-compose ps\n")
	buf.WriteString("```\n\n")

	buf.WriteString("### 2. Migrate Data\n\n")
	buf.WriteString("Run the appropriate migration scripts:\n\n")

	// Check which migration scripts are needed
	hasS3 := false
	hasRDS := false
	hasDynamoDB := false

	for _, result := range results {
		// result.Scripts is now map[string][]byte
		for scriptName := range result.Scripts {
			if strings.Contains(scriptName, "s3") || strings.Contains(scriptName, "S3") {
				hasS3 = true
			}
			if strings.Contains(scriptName, "rds") || strings.Contains(scriptName, "RDS") {
				hasRDS = true
			}
			if strings.Contains(scriptName, "dynamodb") || strings.Contains(scriptName, "DynamoDB") {
				hasDynamoDB = true
			}
		}
	}

	if hasS3 {
		buf.WriteString("#### S3 to MinIO\n\n")
		buf.WriteString("```bash\n")
		buf.WriteString("./scripts/migrate-s3.sh\n")
		buf.WriteString("```\n\n")
	}

	if hasRDS {
		buf.WriteString("#### RDS to PostgreSQL/MySQL\n\n")
		buf.WriteString("```bash\n")
		buf.WriteString("./scripts/migrate-rds.sh\n")
		buf.WriteString("```\n\n")
	}

	if hasDynamoDB {
		buf.WriteString("#### DynamoDB to Local DynamoDB\n\n")
		buf.WriteString("```bash\n")
		buf.WriteString("./scripts/migrate-dynamodb.sh\n")
		buf.WriteString("```\n\n")
	}

	buf.WriteString("### 3. Verify Migration\n\n")
	buf.WriteString("After migration, verify that:\n\n")
	buf.WriteString("1. All services are running: `docker-compose ps`\n")
	buf.WriteString("2. Data has been migrated correctly\n")
	buf.WriteString("3. Application can connect to new services\n")
	buf.WriteString("4. SSL certificates are issued successfully\n\n")

	buf.WriteString("### 4. Update Application Configuration\n\n")
	buf.WriteString("Update your application to point to the new services:\n\n")

	for _, result := range results {
		// result.DockerService is now a single service, not a slice
		if result.DockerService != nil {
			svc := result.DockerService
			if len(svc.Ports) > 0 {
				buf.WriteString(fmt.Sprintf("- **%s**: ", svc.Name))
				if len(svc.Ports) > 0 {
					// Extract port from first port mapping
					port := strings.Split(svc.Ports[0], ":")[0]
					buf.WriteString(fmt.Sprintf("localhost:%s", port))
				}
				buf.WriteString("\n")
			}
		}
	}

	buf.WriteString("\n### 5. Monitor and Test\n\n")
	buf.WriteString("1. Run your application test suite\n")
	buf.WriteString("2. Monitor service logs: `docker-compose logs -f`\n")
	buf.WriteString("3. Check resource usage: `docker stats`\n")
	buf.WriteString("4. Verify backups are working: `./scripts/backup.sh`\n\n")

	buf.WriteString("### 6. Decommission AWS Resources\n\n")
	buf.WriteString("**Only after thoroughly testing the migration:**\n\n")
	buf.WriteString("1. Keep AWS resources running in parallel for at least 1 week\n")
	buf.WriteString("2. Verify all functionality works with self-hosted services\n")
	buf.WriteString("3. Create final backups of AWS resources\n")
	buf.WriteString("4. Gradually decommission AWS resources\n")
	buf.WriteString("5. Monitor for any issues after decommissioning\n\n")

	buf.WriteString("## Rollback Plan\n\n")
	buf.WriteString("If issues occur during migration:\n\n")
	buf.WriteString("1. Keep AWS resources running during migration\n")
	buf.WriteString("2. Update application configuration to point back to AWS\n")
	buf.WriteString("3. Review migration logs for errors\n")
	buf.WriteString("4. Fix issues and retry migration\n\n")

	buf.WriteString("## Warnings\n\n")
	for _, result := range results {
		for _, warning := range result.Warnings {
			buf.WriteString(fmt.Sprintf("- %s\n", warning))
		}
	}

	return buf.String(), nil
}

// generateEnvExample generates the .env.example file.
func (g *Generator) generateEnvExample(results []*mapper.MappingResult) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("# Environment Configuration\n")
	buf.WriteString(fmt.Sprintf("# Generated by Homeport - %s\n\n", time.Now().Format(time.RFC3339)))

	// Collect all environment variables
	envVars := make(map[string]string)

	// Add common variables
	envVars["DOMAIN"] = g.domain
	envVars["EMAIL"] = "your-email@example.com"
	envVars["TZ"] = "UTC"

	// Collect from services
	for _, result := range results {
		// result.DockerService is now a single service, not a slice
		if result.DockerService != nil {
			for key, value := range result.DockerService.Environment {
				// Don't include actual values, use placeholders
				if strings.Contains(strings.ToUpper(key), "PASSWORD") ||
					strings.Contains(strings.ToUpper(key), "SECRET") ||
					strings.Contains(strings.ToUpper(key), "KEY") {
					envVars[key] = "CHANGE_ME"
				} else if value == "" {
					envVars[key] = ""
				} else {
					envVars[key] = value
				}
			}
		}
	}

	// Sort variables
	keys := make([]string, 0, len(envVars))
	for k := range envVars {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// Group by category
	categories := map[string][]string{
		"General":   []string{},
		"Database":  []string{},
		"Storage":   []string{},
		"Security":  []string{},
		"Other":     []string{},
	}

	for _, key := range keys {
		if strings.Contains(strings.ToUpper(key), "DB") ||
			strings.Contains(strings.ToUpper(key), "POSTGRES") ||
			strings.Contains(strings.ToUpper(key), "MYSQL") {
			categories["Database"] = append(categories["Database"], key)
		} else if strings.Contains(strings.ToUpper(key), "S3") ||
			strings.Contains(strings.ToUpper(key), "MINIO") ||
			strings.Contains(strings.ToUpper(key), "STORAGE") {
			categories["Storage"] = append(categories["Storage"], key)
		} else if strings.Contains(strings.ToUpper(key), "PASSWORD") ||
			strings.Contains(strings.ToUpper(key), "SECRET") ||
			strings.Contains(strings.ToUpper(key), "KEY") {
			categories["Security"] = append(categories["Security"], key)
		} else if key == "DOMAIN" || key == "EMAIL" || key == "TZ" {
			categories["General"] = append(categories["General"], key)
		} else {
			categories["Other"] = append(categories["Other"], key)
		}
	}

	// Write categorized variables
	categoryOrder := []string{"General", "Security", "Database", "Storage", "Other"}
	for _, category := range categoryOrder {
		vars := categories[category]
		if len(vars) > 0 {
			buf.WriteString(fmt.Sprintf("# %s\n", category))
			for _, key := range vars {
				value := envVars[key]
				if value == "" {
					buf.WriteString(fmt.Sprintf("%s=\n", key))
				} else {
					buf.WriteString(fmt.Sprintf("%s=%s\n", key, value))
				}
			}
			buf.WriteString("\n")
		}
	}

	return buf.String(), nil
}

// ServiceInfo holds information about a service for documentation.
type ServiceInfo struct {
	Name        string
	Image       string
	Description string
	Ports       string
	URL         string
}

// getServiceDescription returns a description based on the image name.
func (g *Generator) getServiceDescription(image string) string {
	descriptions := map[string]string{
		"postgres":      "PostgreSQL relational database",
		"mysql":         "MySQL relational database",
		"mariadb":       "MariaDB relational database",
		"mongo":         "MongoDB document database",
		"redis":         "Redis in-memory cache",
		"minio":         "MinIO S3-compatible object storage",
		"traefik":       "Traefik reverse proxy and load balancer",
		"nginx":         "Nginx web server",
		"rabbitmq":      "RabbitMQ message broker",
		"elasticsearch": "Elasticsearch search engine",
	}

	imageLower := strings.ToLower(image)
	for key, desc := range descriptions {
		if strings.Contains(imageLower, key) {
			return desc
		}
	}

	return "Service"
}

// categorizeService categorizes a service by its image.
func (g *Generator) categorizeService(image string) string {
	imageLower := strings.ToLower(image)

	if strings.Contains(imageLower, "postgres") || strings.Contains(imageLower, "mysql") ||
		strings.Contains(imageLower, "mariadb") || strings.Contains(imageLower, "mongo") {
		return "Databases"
	}

	if strings.Contains(imageLower, "redis") || strings.Contains(imageLower, "memcache") {
		return "Caching"
	}

	if strings.Contains(imageLower, "minio") || strings.Contains(imageLower, "s3") {
		return "Object Storage"
	}

	if strings.Contains(imageLower, "traefik") || strings.Contains(imageLower, "nginx") {
		return "Reverse Proxy"
	}

	if strings.Contains(imageLower, "rabbitmq") || strings.Contains(imageLower, "kafka") {
		return "Message Queue"
	}

	return "Other Services"
}

// calculateMinRAM estimates minimum RAM requirements.
func (g *Generator) calculateMinRAM(results []*mapper.MappingResult) int {
	// Base requirement
	ram := 2

	// Add 1GB per service
	for _, result := range results {
		if result.DockerService != nil {
			ram++
		}
	}

	return ram
}

// calculateMinDisk estimates minimum disk requirements.
func (g *Generator) calculateMinDisk(results []*mapper.MappingResult) int {
	// Base requirement
	disk := 20

	// Count data services
	dataServices := 0
	for _, result := range results {
		// result.DockerService is now a single service, not a slice
		if result.DockerService != nil {
			if len(result.DockerService.Volumes) > 0 {
				dataServices++
			}
		}
	}

	// Add 10GB per data service
	disk += dataServices * 10

	return disk
}

// extractHostFromRule extracts the host from a Traefik rule.
func extractHostFromRule(rule string) string {
	// Simple extraction: Host(`example.com`) -> https://example.com
	start := strings.Index(rule, "Host(`")
	if start == -1 {
		return ""
	}

	start += 6 // len("Host(`")
	end := strings.Index(rule[start:], "`")
	if end == -1 {
		return ""
	}

	host := rule[start : start+end]
	return "https://" + host
}
