package swarm

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/homeport/homeport/internal/domain/generator"
	"github.com/homeport/homeport/internal/domain/mapper"
	"github.com/homeport/homeport/internal/domain/target"
)

// StackGenerator generates Docker Swarm stack files.
type StackGenerator struct {
	projectName string
	config      *generator.TargetConfig
	networks    *NetworkConfig
}

// NetworkConfig holds overlay network configuration.
type NetworkConfig struct {
	networks map[string]*Network
}

// Network represents a Docker overlay network.
type Network struct {
	Driver     string
	Attachable bool
	Internal   bool
	Encrypted  bool
	Labels     map[string]string
}

// StackFile represents a complete docker-stack.yml structure.
type StackFile struct {
	Version  string
	Services map[string]*SwarmService
	Networks map[string]*Network
	Volumes  map[string]*Volume
	Secrets  map[string]*Secret
	Configs  map[string]*Config
}

// Volume represents a Docker volume.
type Volume struct {
	Name       string
	Driver     string
	DriverOpts map[string]string
	Labels     map[string]string
}

// Secret represents a Docker secret.
type Secret struct {
	Name     string
	External bool
	File     string
}

// Config represents a Docker config.
type Config struct {
	Name     string
	External bool
	File     string
}

// NewStackGenerator creates a new stack generator.
func NewStackGenerator(projectName string, config *generator.TargetConfig) *StackGenerator {
	return &StackGenerator{
		projectName: projectName,
		config:      config,
		networks:    newNetworkConfig(),
	}
}

// newNetworkConfig creates default network configuration for Swarm.
func newNetworkConfig() *NetworkConfig {
	nc := &NetworkConfig{
		networks: make(map[string]*Network),
	}

	// Web network for public-facing services
	nc.networks["web"] = &Network{
		Driver:     "overlay",
		Attachable: true,
		Internal:   false,
		Labels: map[string]string{
			"com.homeport.network": "public",
			"com.homeport.type":    "web",
		},
	}

	// Internal network for service-to-service communication
	nc.networks["internal"] = &Network{
		Driver:     "overlay",
		Attachable: true,
		Internal:   true,
		Encrypted:  true,
		Labels: map[string]string{
			"com.homeport.network": "private",
			"com.homeport.type":    "internal",
		},
	}

	return nc
}

// Generate creates the stack file content from mapping results.
func (g *StackGenerator) Generate(results []*mapper.MappingResult) (string, error) {
	var buf bytes.Buffer

	// Write header
	buf.WriteString(fmt.Sprintf("# Docker Swarm Stack - Generated by Homeport\n"))
	buf.WriteString(fmt.Sprintf("# Project: %s\n", g.projectName))
	buf.WriteString(fmt.Sprintf("# HA Level: %s\n", g.config.HALevel))
	buf.WriteString(fmt.Sprintf("# Generated: %s\n\n", time.Now().Format(time.RFC3339)))
	buf.WriteString("version: \"3.8\"\n\n")

	// Collect all services
	services := g.collectServices(results)

	// Write services
	buf.WriteString("services:\n")
	serviceNames := make([]string, 0, len(services))
	for name := range services {
		serviceNames = append(serviceNames, name)
	}
	sort.Strings(serviceNames)

	for _, name := range serviceNames {
		svc := services[name]
		if err := g.writeService(&buf, svc); err != nil {
			return "", fmt.Errorf("failed to write service %s: %w", name, err)
		}
	}

	// Write networks
	g.writeNetworks(&buf)

	// Write volumes
	volumes := g.collectVolumes(services)
	if len(volumes) > 0 {
		g.writeVolumes(&buf, volumes)
	}

	return buf.String(), nil
}

// collectServices gathers all services from mapping results.
func (g *StackGenerator) collectServices(results []*mapper.MappingResult) map[string]*SwarmService {
	services := make(map[string]*SwarmService)

	for _, result := range results {
		if result == nil {
			continue
		}

		// Convert main service
		if result.DockerService != nil {
			svc := g.convertToSwarmService(result.DockerService)
			services[svc.Name] = svc
		}

		// Convert additional services
		for _, additionalSvc := range result.AdditionalServices {
			if additionalSvc != nil {
				svc := g.convertToSwarmService(additionalSvc)
				services[svc.Name] = svc
			}
		}
	}

	return services
}

// convertToSwarmService converts a mapper.DockerService to a SwarmService.
func (g *StackGenerator) convertToSwarmService(dockerSvc *mapper.DockerService) *SwarmService {
	svc := &SwarmService{
		Name:        dockerSvc.Name,
		Image:       dockerSvc.Image,
		Environment: dockerSvc.Environment,
		Ports:       dockerSvc.Ports,
		Volumes:     dockerSvc.Volumes,
		Networks:    g.assignNetworks(dockerSvc),
		DependsOn:   dockerSvc.DependsOn,
		Command:     dockerSvc.Command,
		Labels:      dockerSvc.Labels,
	}

	// Set up deploy configuration based on HA level
	svc.Deploy = g.createDeployConfig(dockerSvc)

	// Convert health check
	if dockerSvc.HealthCheck != nil {
		svc.HealthCheck = &HealthCheck{
			Test:        dockerSvc.HealthCheck.Test,
			Interval:    dockerSvc.HealthCheck.Interval.String(),
			Timeout:     dockerSvc.HealthCheck.Timeout.String(),
			Retries:     dockerSvc.HealthCheck.Retries,
			StartPeriod: "30s",
		}
	}

	return svc
}

// assignNetworks determines which networks a service should be connected to.
func (g *StackGenerator) assignNetworks(svc *mapper.DockerService) []string {
	networks := []string{}

	// Check if service has public-facing labels (Traefik)
	hasPublicLabels := false
	for key := range svc.Labels {
		if strings.HasPrefix(key, "traefik.") {
			hasPublicLabels = true
			break
		}
	}

	// Check if service exposes ports
	hasPorts := len(svc.Ports) > 0

	if hasPublicLabels || hasPorts {
		networks = append(networks, "web")
	}

	// All services get the internal network
	networks = append(networks, "internal")

	return networks
}

// createDeployConfig creates Swarm deploy configuration based on HA level.
func (g *StackGenerator) createDeployConfig(dockerSvc *mapper.DockerService) *DeployConfig {
	deploy := &DeployConfig{
		Replicas:      g.getReplicaCount(),
		UpdateConfig:  g.createUpdateConfig(),
		RollbackConfig: g.createRollbackConfig(),
		RestartPolicy: g.createRestartPolicy(),
	}

	// Set placement constraints based on HA level
	if g.config.HALevel.RequiresCluster() {
		deploy.Placement = &Placement{
			Constraints: []string{"node.role == worker"},
			Preferences: []PlacementPreference{
				{Spread: "node.id"},
			},
		}
	} else if g.config.HALevel.RequiresMultiServer() {
		deploy.Placement = &Placement{
			Constraints: []string{"node.role == worker"},
		}
	}

	// Copy resource limits if specified in the original service
	if dockerSvc.Deploy != nil && dockerSvc.Deploy.Resources != nil {
		deploy.Resources = &Resources{}
		if dockerSvc.Deploy.Resources.Limits != nil {
			deploy.Resources.Limits = &ResourceLimits{
				CPUs:   dockerSvc.Deploy.Resources.Limits.CPUs,
				Memory: dockerSvc.Deploy.Resources.Limits.Memory,
			}
		}
		if dockerSvc.Deploy.Resources.Reservations != nil {
			deploy.Resources.Reservations = &ResourceLimits{
				CPUs:   dockerSvc.Deploy.Resources.Reservations.CPUs,
				Memory: dockerSvc.Deploy.Resources.Reservations.Memory,
			}
		}
	}

	return deploy
}

// getReplicaCount returns the number of replicas based on HA level.
func (g *StackGenerator) getReplicaCount() int {
	switch g.config.HALevel {
	case target.HALevelCluster:
		return 3
	case target.HALevelMultiServer:
		return 2
	case target.HALevelBasic:
		return 1
	default:
		return 1
	}
}

// createUpdateConfig creates update configuration for rolling updates.
func (g *StackGenerator) createUpdateConfig() *UpdateConfig {
	switch g.config.HALevel {
	case target.HALevelCluster:
		return &UpdateConfig{
			Parallelism:   1,
			Delay:         "10s",
			FailureAction: "rollback",
			Order:         "start-first",
			Monitor:       "30s",
		}
	case target.HALevelMultiServer:
		return &UpdateConfig{
			Parallelism:   1,
			Delay:         "15s",
			FailureAction: "rollback",
			Order:         "stop-first",
			Monitor:       "30s",
		}
	default:
		return &UpdateConfig{
			Parallelism:   1,
			Delay:         "10s",
			FailureAction: "pause",
			Order:         "stop-first",
		}
	}
}

// createRollbackConfig creates rollback configuration.
func (g *StackGenerator) createRollbackConfig() *RollbackConfig {
	return &RollbackConfig{
		Parallelism: 1,
		Delay:       "5s",
		Order:       "stop-first",
	}
}

// createRestartPolicy creates restart policy configuration.
func (g *StackGenerator) createRestartPolicy() *RestartPolicy {
	switch g.config.HALevel {
	case target.HALevelCluster, target.HALevelMultiServer:
		return &RestartPolicy{
			Condition:   "any",
			Delay:       "5s",
			MaxAttempts: 5,
			Window:      "120s",
		}
	default:
		return &RestartPolicy{
			Condition:   "on-failure",
			Delay:       "5s",
			MaxAttempts: 3,
			Window:      "120s",
		}
	}
}

// writeService writes a single service to the buffer.
func (g *StackGenerator) writeService(buf *bytes.Buffer, svc *SwarmService) error {
	buf.WriteString(fmt.Sprintf("  %s:\n", svc.Name))
	buf.WriteString(fmt.Sprintf("    image: %s\n", svc.Image))

	// Deploy configuration (Swarm-specific)
	g.writeDeployConfig(buf, svc.Deploy)

	// Environment variables
	if len(svc.Environment) > 0 {
		buf.WriteString("    environment:\n")
		keys := sortedKeys(svc.Environment)
		for _, k := range keys {
			v := svc.Environment[k]
			if strings.ContainsAny(v, " \n\t:{}[]!@#$%^&*") {
				buf.WriteString(fmt.Sprintf("      %s: \"%s\"\n", k, escapeYAML(v)))
			} else {
				buf.WriteString(fmt.Sprintf("      %s: %s\n", k, v))
			}
		}
	}

	// Ports
	if len(svc.Ports) > 0 {
		buf.WriteString("    ports:\n")
		for _, port := range svc.Ports {
			buf.WriteString(fmt.Sprintf("      - \"%s\"\n", port))
		}
	}

	// Volumes
	if len(svc.Volumes) > 0 {
		buf.WriteString("    volumes:\n")
		for _, vol := range svc.Volumes {
			buf.WriteString(fmt.Sprintf("      - %s\n", vol))
		}
	}

	// Networks
	if len(svc.Networks) > 0 {
		buf.WriteString("    networks:\n")
		for _, net := range svc.Networks {
			buf.WriteString(fmt.Sprintf("      - %s\n", net))
		}
	}

	// Dependencies
	if len(svc.DependsOn) > 0 {
		buf.WriteString("    depends_on:\n")
		for _, dep := range svc.DependsOn {
			buf.WriteString(fmt.Sprintf("      - %s\n", dep))
		}
	}

	// Command
	if len(svc.Command) > 0 {
		buf.WriteString("    command:\n")
		for _, cmd := range svc.Command {
			buf.WriteString(fmt.Sprintf("      - %s\n", cmd))
		}
	}

	// Health check
	if svc.HealthCheck != nil {
		buf.WriteString("    healthcheck:\n")
		if len(svc.HealthCheck.Test) > 0 {
			buf.WriteString("      test:\n")
			for _, t := range svc.HealthCheck.Test {
				buf.WriteString(fmt.Sprintf("        - %s\n", t))
			}
		}
		if svc.HealthCheck.Interval != "" {
			buf.WriteString(fmt.Sprintf("      interval: %s\n", svc.HealthCheck.Interval))
		}
		if svc.HealthCheck.Timeout != "" {
			buf.WriteString(fmt.Sprintf("      timeout: %s\n", svc.HealthCheck.Timeout))
		}
		if svc.HealthCheck.Retries > 0 {
			buf.WriteString(fmt.Sprintf("      retries: %d\n", svc.HealthCheck.Retries))
		}
		if svc.HealthCheck.StartPeriod != "" {
			buf.WriteString(fmt.Sprintf("      start_period: %s\n", svc.HealthCheck.StartPeriod))
		}
	}

	// Labels
	if len(svc.Labels) > 0 {
		buf.WriteString("    labels:\n")
		keys := sortedKeys(svc.Labels)
		for _, k := range keys {
			v := svc.Labels[k]
			buf.WriteString(fmt.Sprintf("      %s: \"%s\"\n", k, escapeYAML(v)))
		}
	}

	buf.WriteString("\n")
	return nil
}

// writeDeployConfig writes the deploy section for a Swarm service.
func (g *StackGenerator) writeDeployConfig(buf *bytes.Buffer, deploy *DeployConfig) {
	buf.WriteString("    deploy:\n")
	buf.WriteString(fmt.Sprintf("      replicas: %d\n", deploy.Replicas))

	// Update config
	if deploy.UpdateConfig != nil {
		buf.WriteString("      update_config:\n")
		buf.WriteString(fmt.Sprintf("        parallelism: %d\n", deploy.UpdateConfig.Parallelism))
		if deploy.UpdateConfig.Delay != "" {
			buf.WriteString(fmt.Sprintf("        delay: %s\n", deploy.UpdateConfig.Delay))
		}
		if deploy.UpdateConfig.FailureAction != "" {
			buf.WriteString(fmt.Sprintf("        failure_action: %s\n", deploy.UpdateConfig.FailureAction))
		}
		if deploy.UpdateConfig.Order != "" {
			buf.WriteString(fmt.Sprintf("        order: %s\n", deploy.UpdateConfig.Order))
		}
		if deploy.UpdateConfig.Monitor != "" {
			buf.WriteString(fmt.Sprintf("        monitor: %s\n", deploy.UpdateConfig.Monitor))
		}
	}

	// Rollback config
	if deploy.RollbackConfig != nil {
		buf.WriteString("      rollback_config:\n")
		buf.WriteString(fmt.Sprintf("        parallelism: %d\n", deploy.RollbackConfig.Parallelism))
		if deploy.RollbackConfig.Delay != "" {
			buf.WriteString(fmt.Sprintf("        delay: %s\n", deploy.RollbackConfig.Delay))
		}
		if deploy.RollbackConfig.Order != "" {
			buf.WriteString(fmt.Sprintf("        order: %s\n", deploy.RollbackConfig.Order))
		}
	}

	// Restart policy
	if deploy.RestartPolicy != nil {
		buf.WriteString("      restart_policy:\n")
		if deploy.RestartPolicy.Condition != "" {
			buf.WriteString(fmt.Sprintf("        condition: %s\n", deploy.RestartPolicy.Condition))
		}
		if deploy.RestartPolicy.Delay != "" {
			buf.WriteString(fmt.Sprintf("        delay: %s\n", deploy.RestartPolicy.Delay))
		}
		if deploy.RestartPolicy.MaxAttempts > 0 {
			buf.WriteString(fmt.Sprintf("        max_attempts: %d\n", deploy.RestartPolicy.MaxAttempts))
		}
		if deploy.RestartPolicy.Window != "" {
			buf.WriteString(fmt.Sprintf("        window: %s\n", deploy.RestartPolicy.Window))
		}
	}

	// Placement
	if deploy.Placement != nil {
		buf.WriteString("      placement:\n")
		if len(deploy.Placement.Constraints) > 0 {
			buf.WriteString("        constraints:\n")
			for _, c := range deploy.Placement.Constraints {
				buf.WriteString(fmt.Sprintf("          - %s\n", c))
			}
		}
		if len(deploy.Placement.Preferences) > 0 {
			buf.WriteString("        preferences:\n")
			for _, p := range deploy.Placement.Preferences {
				buf.WriteString(fmt.Sprintf("          - spread: %s\n", p.Spread))
			}
		}
	}

	// Resources
	if deploy.Resources != nil {
		buf.WriteString("      resources:\n")
		if deploy.Resources.Limits != nil {
			buf.WriteString("        limits:\n")
			if deploy.Resources.Limits.CPUs != "" {
				buf.WriteString(fmt.Sprintf("          cpus: '%s'\n", deploy.Resources.Limits.CPUs))
			}
			if deploy.Resources.Limits.Memory != "" {
				buf.WriteString(fmt.Sprintf("          memory: %s\n", deploy.Resources.Limits.Memory))
			}
		}
		if deploy.Resources.Reservations != nil {
			buf.WriteString("        reservations:\n")
			if deploy.Resources.Reservations.CPUs != "" {
				buf.WriteString(fmt.Sprintf("          cpus: '%s'\n", deploy.Resources.Reservations.CPUs))
			}
			if deploy.Resources.Reservations.Memory != "" {
				buf.WriteString(fmt.Sprintf("          memory: %s\n", deploy.Resources.Reservations.Memory))
			}
		}
	}
}

// writeNetworks writes the networks section.
func (g *StackGenerator) writeNetworks(buf *bytes.Buffer) {
	buf.WriteString("\nnetworks:\n")

	networkNames := make([]string, 0, len(g.networks.networks))
	for name := range g.networks.networks {
		networkNames = append(networkNames, name)
	}
	sort.Strings(networkNames)

	for _, name := range networkNames {
		net := g.networks.networks[name]
		buf.WriteString(fmt.Sprintf("  %s:\n", name))
		buf.WriteString(fmt.Sprintf("    driver: %s\n", net.Driver))
		if net.Attachable {
			buf.WriteString("    attachable: true\n")
		}
		if net.Internal {
			buf.WriteString("    internal: true\n")
		}
		if net.Encrypted {
			buf.WriteString("    driver_opts:\n")
			buf.WriteString("      encrypted: \"true\"\n")
		}
		if len(net.Labels) > 0 {
			buf.WriteString("    labels:\n")
			for k, v := range net.Labels {
				buf.WriteString(fmt.Sprintf("      %s: \"%s\"\n", k, v))
			}
		}
	}
}

// collectVolumes extracts named volumes from services.
func (g *StackGenerator) collectVolumes(services map[string]*SwarmService) map[string]*Volume {
	volumes := make(map[string]*Volume)

	for _, svc := range services {
		for _, vol := range svc.Volumes {
			// Named volumes don't contain path separators or dots at the start
			if !strings.Contains(vol, "/") && !strings.HasPrefix(vol, ".") {
				parts := strings.Split(vol, ":")
				if len(parts) > 0 {
					volName := parts[0]
					if _, exists := volumes[volName]; !exists {
						volumes[volName] = &Volume{
							Name:   volName,
							Driver: "local",
						}
					}
				}
			}
		}
	}

	return volumes
}

// writeVolumes writes the volumes section.
func (g *StackGenerator) writeVolumes(buf *bytes.Buffer, volumes map[string]*Volume) {
	buf.WriteString("\nvolumes:\n")

	volumeNames := make([]string, 0, len(volumes))
	for name := range volumes {
		volumeNames = append(volumeNames, name)
	}
	sort.Strings(volumeNames)

	for _, name := range volumeNames {
		vol := volumes[name]
		buf.WriteString(fmt.Sprintf("  %s:\n", name))
		if vol.Driver != "" {
			buf.WriteString(fmt.Sprintf("    driver: %s\n", vol.Driver))
		}
		if len(vol.DriverOpts) > 0 {
			buf.WriteString("    driver_opts:\n")
			for k, v := range vol.DriverOpts {
				buf.WriteString(fmt.Sprintf("      %s: \"%s\"\n", k, v))
			}
		}
		if len(vol.Labels) > 0 {
			buf.WriteString("    labels:\n")
			for k, v := range vol.Labels {
				buf.WriteString(fmt.Sprintf("      %s: \"%s\"\n", k, v))
			}
		}
	}
}

// sortedKeys returns sorted keys from a map.
func sortedKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

// escapeYAML escapes special characters in YAML strings.
func escapeYAML(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}
