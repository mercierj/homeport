// Package objectstore provides shared utilities for object storage mapping.
package objectstore

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strings"
	"text/template"
)

// LifecycleFilter defines conditions for applying lifecycle rules.
type LifecycleFilter struct {
	Prefix                  string
	Tags                    map[string]string
	ObjectSizeGreaterThan   int64
	ObjectSizeLessThan      int64
	MatchAnyStorageClass    []string
	NoncurrentVersions      int
	NewerNoncurrentVersions int
	DaysAfterNoncurrentTime int
	DaysAfterLastModified   int
	DaysAfterObjectCreation int
}

// MinIOLifecycleJSONConfig defines the MinIO-compatible lifecycle JSON structure.
type MinIOLifecycleJSONConfig struct {
	Rules []MinIOLifecycleRuleJSON `json:"Rules"`
}

// MinIOLifecycleRuleJSON represents a single lifecycle rule in MinIO format.
type MinIOLifecycleRuleJSON struct {
	ID         string                        `json:"ID"`
	Status     string                        `json:"Status"`
	Filter     *MinIOLifecycleFilterJSON     `json:"Filter,omitempty"`
	Expiration *MinIOLifecycleExpirationJSON `json:"Expiration,omitempty"`
	Transition *MinIOLifecycleTransitionJSON `json:"Transition,omitempty"`
}

// MinIOLifecycleFilterJSON represents the filter in MinIO lifecycle format.
type MinIOLifecycleFilterJSON struct {
	Prefix string                       `json:"Prefix,omitempty"`
	Tag    *MinIOLifecycleTagJSON       `json:"Tag,omitempty"`
	And    *MinIOLifecycleFilterAndJSON `json:"And,omitempty"`
}

// MinIOLifecycleFilterAndJSON represents combined filter conditions.
type MinIOLifecycleFilterAndJSON struct {
	Prefix string                  `json:"Prefix,omitempty"`
	Tags   []MinIOLifecycleTagJSON `json:"Tags,omitempty"`
}

// MinIOLifecycleTagJSON represents a tag in MinIO lifecycle format.
type MinIOLifecycleTagJSON struct {
	Key   string `json:"Key"`
	Value string `json:"Value"`
}

// MinIOLifecycleExpirationJSON represents expiration settings.
type MinIOLifecycleExpirationJSON struct {
	Days                      int  `json:"Days,omitempty"`
	ExpiredObjectDeleteMarker bool `json:"ExpiredObjectDeleteMarker,omitempty"`
}

// MinIOLifecycleTransitionJSON represents transition settings.
type MinIOLifecycleTransitionJSON struct {
	Days         int    `json:"Days,omitempty"`
	StorageClass string `json:"StorageClass,omitempty"`
}

// ExtendedLifecycleRule extends LifecycleRule with additional filter options.
type ExtendedLifecycleRule struct {
	LifecycleRule
	Tags   map[string]string
	Filter *LifecycleFilter
}

// MinIOLifecycleScript returns mc ilm commands for lifecycle rules.
func MinIOLifecycleScript(opts *ObjectStoreOptions) []byte {
	if opts == nil || len(opts.LifecycleRules) == 0 {
		return nil
	}

	tmpl := `#!/bin/bash
# MinIO Lifecycle Configuration
# Bucket: {{.BucketName}}
# Generated by Homeport
#
# This script configures lifecycle rules using the MinIO Client (mc).
# Run after MinIO is started and the bucket is created.

set -e

MC_ALIAS="${MC_ALIAS:-local}"
BUCKET="${BUCKET_NAME:-{{.BucketName}}}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  MinIO Lifecycle Configuration"
echo "========================================="
echo ""
echo "Bucket: $BUCKET"
echo "Alias: $MC_ALIAS"
echo ""

# Verify mc is installed
if ! command -v mc >/dev/null 2>&1; then
    log_error "MinIO Client (mc) is not installed"
    echo "Install from: https://min.io/docs/minio/linux/reference/minio-mc.html"
    exit 1
fi

# Verify alias exists
if ! mc alias list "$MC_ALIAS" >/dev/null 2>&1; then
    log_warn "Alias '$MC_ALIAS' not found. Setting up..."
    mc alias set "$MC_ALIAS" http://localhost:9000 minioadmin minioadmin
fi

# Verify bucket exists
if ! mc ls "${MC_ALIAS}/${BUCKET}" >/dev/null 2>&1; then
    log_error "Bucket '${BUCKET}' does not exist"
    echo "Create it with: mc mb ${MC_ALIAS}/${BUCKET}"
    exit 1
fi

{{if .Versioning}}
# Enable versioning first (required for some lifecycle features)
log_info "Enabling versioning on bucket..."
mc version enable "${MC_ALIAS}/${BUCKET}"
{{end}}

log_info "Configuring lifecycle rules..."
echo ""

{{range $index, $rule := .LifecycleRules}}
# Rule: {{$rule.ID}}
log_info "Adding rule: {{$rule.ID}}"
{{if $rule.Enabled}}
mc ilm rule add "${MC_ALIAS}/${BUCKET}" \
{{if $rule.ID}}  --id "{{$rule.ID}}" \
{{end}}{{if gt $rule.ExpirationDays 0}}  --expiry-days {{$rule.ExpirationDays}} \
{{end}}{{if $rule.Prefix}}  --prefix "{{$rule.Prefix}}" \
{{end}}{{if $rule.Transition}}{{if gt $rule.Transition.Days 0}}  --transition-days {{$rule.Transition.Days}} \
  --storage-class "{{$rule.Transition.StorageClass}}" \
{{end}}{{end}}  2>/dev/null || log_warn "Failed to add rule: {{$rule.ID}}"
{{else}}
# Rule is disabled, skipping
log_warn "Rule '{{$rule.ID}}' is disabled, skipping"
{{end}}

{{end}}

echo ""
echo "========================================="
echo "  Lifecycle Configuration Complete"
echo "========================================="
echo ""

# Show current lifecycle rules
log_info "Current lifecycle rules:"
mc ilm rule ls "${MC_ALIAS}/${BUCKET}" 2>/dev/null || log_warn "No lifecycle rules configured"

echo ""
log_info "To view lifecycle rules: mc ilm rule ls ${MC_ALIAS}/${BUCKET}"
log_info "To remove a rule: mc ilm rule rm ${MC_ALIAS}/${BUCKET} --id <rule-id>"
`

	t, err := template.New("lifecycle-script").Parse(tmpl)
	if err != nil {
		return nil
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, opts); err != nil {
		return nil
	}

	return buf.Bytes()
}

// MinIOVersioningScript returns mc versioning commands.
func MinIOVersioningScript(opts *ObjectStoreOptions) []byte {
	if opts == nil {
		return nil
	}

	tmpl := `#!/bin/bash
# MinIO Versioning Configuration
# Bucket: {{.BucketName}}
# Generated by Homeport
#
# This script enables versioning on a MinIO bucket.
# Versioning allows keeping multiple versions of objects.

set -e

MC_ALIAS="${MC_ALIAS:-local}"
BUCKET="${BUCKET_NAME:-{{.BucketName}}}"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  MinIO Versioning Configuration"
echo "========================================="
echo ""

# Verify mc is installed
if ! command -v mc >/dev/null 2>&1; then
    log_error "MinIO Client (mc) is not installed"
    exit 1
fi

# Verify alias exists
if ! mc alias list "$MC_ALIAS" >/dev/null 2>&1; then
    log_info "Setting up alias..."
    mc alias set "$MC_ALIAS" http://localhost:9000 minioadmin minioadmin
fi

# Enable versioning
log_info "Enabling versioning for bucket: $BUCKET"
mc version enable "${MC_ALIAS}/${BUCKET}"

echo ""
echo "Versioning enabled for bucket: ${BUCKET}"
echo ""

# Show current versioning status
log_info "Current versioning status:"
mc version info "${MC_ALIAS}/${BUCKET}"

echo ""
log_info "To suspend versioning: mc version suspend ${MC_ALIAS}/${BUCKET}"
log_info "To list object versions: mc ls --versions ${MC_ALIAS}/${BUCKET}"
`

	t, err := template.New("versioning-script").Parse(tmpl)
	if err != nil {
		return nil
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, opts); err != nil {
		return nil
	}

	return buf.Bytes()
}

// MinIOLifecycleJSON returns lifecycle JSON configuration.
func MinIOLifecycleJSON(opts *ObjectStoreOptions) []byte {
	if opts == nil || len(opts.LifecycleRules) == 0 {
		return nil
	}

	config := MinIOLifecycleJSONConfig{
		Rules: make([]MinIOLifecycleRuleJSON, 0, len(opts.LifecycleRules)),
	}

	for _, rule := range opts.LifecycleRules {
		minioRule := MinIOLifecycleRuleJSON{
			ID: rule.ID,
		}

		// Set status
		if rule.Enabled {
			minioRule.Status = "Enabled"
		} else {
			minioRule.Status = "Disabled"
		}

		// Build filter for prefix
		if rule.Prefix != "" {
			minioRule.Filter = &MinIOLifecycleFilterJSON{
				Prefix: rule.Prefix,
			}
		}

		// Set expiration
		if rule.ExpirationDays > 0 {
			minioRule.Expiration = &MinIOLifecycleExpirationJSON{
				Days: rule.ExpirationDays,
			}
		}

		// Set transition
		if rule.Transition != nil && rule.Transition.Days > 0 {
			minioRule.Transition = &MinIOLifecycleTransitionJSON{
				Days:         rule.Transition.Days,
				StorageClass: rule.Transition.StorageClass,
			}
		}

		config.Rules = append(config.Rules, minioRule)
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return nil
	}

	return data
}

// GenerateLifecycleFromS3 converts S3 lifecycle rules to MinIO format.
func GenerateLifecycleFromS3(rules []interface{}) []LifecycleRule {
	result := make([]LifecycleRule, 0, len(rules))

	for i, rule := range rules {
		ruleMap, ok := rule.(map[string]interface{})
		if !ok {
			continue
		}

		lifecycleRule := LifecycleRule{
			ID:      fmt.Sprintf("s3-rule-%d", i),
			Enabled: true,
		}

		// Extract ID
		if id, ok := ruleMap["id"].(string); ok {
			lifecycleRule.ID = id
		}

		// Extract enabled status
		if enabled, ok := ruleMap["enabled"].(bool); ok {
			lifecycleRule.Enabled = enabled
		}
		if status, ok := ruleMap["status"].(string); ok {
			lifecycleRule.Enabled = strings.EqualFold(status, "enabled")
		}

		// Extract prefix
		if prefix, ok := ruleMap["prefix"].(string); ok {
			lifecycleRule.Prefix = prefix
		}

		// Extract filter
		if filter, ok := ruleMap["filter"].(map[string]interface{}); ok {
			if prefix, ok := filter["prefix"].(string); ok {
				lifecycleRule.Prefix = prefix
			}
		}

		// Extract expiration
		if expiration, ok := ruleMap["expiration"].(map[string]interface{}); ok {
			if days, ok := expiration["days"].(float64); ok {
				lifecycleRule.ExpirationDays = int(days)
			} else if days, ok := expiration["days"].(int); ok {
				lifecycleRule.ExpirationDays = days
			}
		}

		// Extract transition
		if transitions, ok := ruleMap["transition"].([]interface{}); ok && len(transitions) > 0 {
			if transMap, ok := transitions[0].(map[string]interface{}); ok {
				lifecycleRule.Transition = &TransitionRule{}
				if days, ok := transMap["days"].(float64); ok {
					lifecycleRule.Transition.Days = int(days)
				} else if days, ok := transMap["days"].(int); ok {
					lifecycleRule.Transition.Days = days
				}
				if storageClass, ok := transMap["storage_class"].(string); ok {
					lifecycleRule.Transition.StorageClass = mapS3StorageClass(storageClass)
				}
			}
		} else if transition, ok := ruleMap["transition"].(map[string]interface{}); ok {
			lifecycleRule.Transition = &TransitionRule{}
			if days, ok := transition["days"].(float64); ok {
				lifecycleRule.Transition.Days = int(days)
			} else if days, ok := transition["days"].(int); ok {
				lifecycleRule.Transition.Days = days
			}
			if storageClass, ok := transition["storage_class"].(string); ok {
				lifecycleRule.Transition.StorageClass = mapS3StorageClass(storageClass)
			}
		}

		result = append(result, lifecycleRule)
	}

	return result
}

// GenerateLifecycleFromGCS converts GCS lifecycle rules to MinIO format.
func GenerateLifecycleFromGCS(rules []interface{}) []LifecycleRule {
	result := make([]LifecycleRule, 0, len(rules))

	for i, rule := range rules {
		ruleMap, ok := rule.(map[string]interface{})
		if !ok {
			continue
		}

		lifecycleRule := LifecycleRule{
			ID:      fmt.Sprintf("gcs-rule-%d", i),
			Enabled: true,
		}

		// GCS lifecycle rules have action and condition
		if action, ok := ruleMap["action"].(map[string]interface{}); ok {
			actionType, _ := action["type"].(string)

			switch strings.ToLower(actionType) {
			case "delete":
				// Will be handled by expiration
			case "setclass", "setstorageclass":
				if storageClass, ok := action["storage_class"].(string); ok {
					lifecycleRule.Transition = &TransitionRule{
						StorageClass: mapGCSStorageClass(storageClass),
					}
				}
			}
		}

		// Extract condition
		if condition, ok := ruleMap["condition"].(map[string]interface{}); ok {
			// age (days since creation)
			if age, ok := condition["age"].(float64); ok {
				if lifecycleRule.Transition != nil {
					lifecycleRule.Transition.Days = int(age)
				} else {
					lifecycleRule.ExpirationDays = int(age)
				}
			}

			// matches_prefix
			if prefixes, ok := condition["matches_prefix"].([]interface{}); ok && len(prefixes) > 0 {
				if prefix, ok := prefixes[0].(string); ok {
					lifecycleRule.Prefix = prefix
				}
			}
		}

		result = append(result, lifecycleRule)
	}

	return result
}

// GenerateLifecycleFromAzure converts Azure Blob lifecycle rules to MinIO format.
func GenerateLifecycleFromAzure(rules []interface{}) []LifecycleRule {
	result := make([]LifecycleRule, 0, len(rules))

	for i, rule := range rules {
		ruleMap, ok := rule.(map[string]interface{})
		if !ok {
			continue
		}

		lifecycleRule := LifecycleRule{
			ID:      fmt.Sprintf("azure-rule-%d", i),
			Enabled: true,
		}

		// Extract name
		if name, ok := ruleMap["name"].(string); ok {
			lifecycleRule.ID = name
		}

		// Extract enabled
		if enabled, ok := ruleMap["enabled"].(bool); ok {
			lifecycleRule.Enabled = enabled
		}

		// Extract filters
		if filters, ok := ruleMap["filters"].(map[string]interface{}); ok {
			if prefixMatch, ok := filters["prefix_match"].([]interface{}); ok && len(prefixMatch) > 0 {
				if prefix, ok := prefixMatch[0].(string); ok {
					lifecycleRule.Prefix = prefix
				}
			}
		}

		// Extract actions
		if actions, ok := ruleMap["actions"].(map[string]interface{}); ok {
			// Base blob actions
			if baseBlob, ok := actions["base_blob"].(map[string]interface{}); ok {
				if deleteAfterDays, ok := baseBlob["delete_after_days_since_modification_greater_than"].(float64); ok {
					lifecycleRule.ExpirationDays = int(deleteAfterDays)
				}
				if tierToCool, ok := baseBlob["tier_to_cool_after_days_since_modification_greater_than"].(float64); ok {
					lifecycleRule.Transition = &TransitionRule{
						Days:         int(tierToCool),
						StorageClass: "STANDARD_IA", // Map Azure Cool to MinIO equivalent
					}
				}
				if tierToArchive, ok := baseBlob["tier_to_archive_after_days_since_modification_greater_than"].(float64); ok {
					// If no transition set yet, use archive
					if lifecycleRule.Transition == nil {
						lifecycleRule.Transition = &TransitionRule{
							Days:         int(tierToArchive),
							StorageClass: "GLACIER",
						}
					}
				}
			}
		}

		result = append(result, lifecycleRule)
	}

	return result
}

// mapS3StorageClass maps S3 storage classes to MinIO equivalents.
func mapS3StorageClass(s3Class string) string {
	mapping := map[string]string{
		"STANDARD":            "STANDARD",
		"STANDARD_IA":         "STANDARD_IA",
		"ONEZONE_IA":          "ONEZONE_IA",
		"INTELLIGENT_TIERING": "STANDARD", // No direct equivalent
		"GLACIER":             "GLACIER",
		"GLACIER_IR":          "GLACIER",
		"DEEP_ARCHIVE":        "DEEP_ARCHIVE",
		"REDUCED_REDUNDANCY":  "REDUCED_REDUNDANCY",
	}

	if mapped, ok := mapping[strings.ToUpper(s3Class)]; ok {
		return mapped
	}
	return s3Class
}

// mapGCSStorageClass maps GCS storage classes to MinIO equivalents.
func mapGCSStorageClass(gcsClass string) string {
	mapping := map[string]string{
		"STANDARD":       "STANDARD",
		"NEARLINE":       "STANDARD_IA",
		"COLDLINE":       "GLACIER",
		"ARCHIVE":        "DEEP_ARCHIVE",
		"MULTI_REGIONAL": "STANDARD",
		"REGIONAL":       "STANDARD",
	}

	if mapped, ok := mapping[strings.ToUpper(gcsClass)]; ok {
		return mapped
	}
	return gcsClass
}

// MinIORetentionScript returns mc retention commands for object locking.
func MinIORetentionScript(bucketName, retentionMode string, retentionDays int) []byte {
	if bucketName == "" || retentionMode == "" || retentionDays <= 0 {
		return nil
	}

	tmpl := `#!/bin/bash
# MinIO Object Lock (Retention) Configuration
# Bucket: {{.BucketName}}
# Generated by Homeport
#
# This script configures object locking for compliance/governance retention.
# IMPORTANT: Object locking must be enabled when creating the bucket.

set -e

MC_ALIAS="${MC_ALIAS:-local}"
BUCKET="${BUCKET_NAME:-{{.BucketName}}}"
RETENTION_MODE="{{.RetentionMode}}"
RETENTION_DAYS="{{.RetentionDays}}"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  MinIO Object Lock Configuration"
echo "========================================="
echo ""
echo "Bucket: $BUCKET"
echo "Mode: $RETENTION_MODE"
echo "Retention: ${RETENTION_DAYS}d"
echo ""

# Verify mc is installed
if ! command -v mc >/dev/null 2>&1; then
    log_error "MinIO Client (mc) is not installed"
    exit 1
fi

# Check if object locking is enabled on bucket
if ! mc retention info "${MC_ALIAS}/${BUCKET}" >/dev/null 2>&1; then
    log_warn "Object locking may not be enabled on this bucket"
    log_warn "To create a bucket with object locking:"
    echo "  mc mb --with-lock ${MC_ALIAS}/${BUCKET}"
fi

# Set default retention
log_info "Setting default retention policy..."
mc retention set --default "$RETENTION_MODE" "${RETENTION_DAYS}d" "${MC_ALIAS}/${BUCKET}"

echo ""
echo "========================================="
echo "  Retention Configuration Complete"
echo "========================================="
echo ""

# Show current retention info
log_info "Current retention configuration:"
mc retention info "${MC_ALIAS}/${BUCKET}"

echo ""
log_info "To clear retention: mc retention clear ${MC_ALIAS}/${BUCKET}"
log_info "Note: COMPLIANCE mode locks cannot be removed until expiry"
`

	data := struct {
		BucketName    string
		RetentionMode string
		RetentionDays int
	}{
		BucketName:    bucketName,
		RetentionMode: retentionMode,
		RetentionDays: retentionDays,
	}

	t, err := template.New("retention-script").Parse(tmpl)
	if err != nil {
		return nil
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return nil
	}

	return buf.Bytes()
}

// GenerateLifecycleExampleScript generates an example lifecycle configuration script.
func GenerateLifecycleExampleScript(bucketName string) []byte {
	return []byte(fmt.Sprintf(`#!/bin/bash
# Example MinIO Lifecycle Configuration
# Bucket: %s
# Generated by Homeport
#
# This is an example script showing common lifecycle patterns.
# Customize based on your requirements.

set -e

MC_ALIAS="${MC_ALIAS:-local}"
BUCKET="%s"

echo "Configuring example lifecycle rules for: $BUCKET"

# Example 1: Delete old logs after 30 days
mc ilm rule add "${MC_ALIAS}/${BUCKET}" \
  --id "delete-old-logs" \
  --expiry-days 30 \
  --prefix "logs/"

# Example 2: Delete temporary files after 7 days
mc ilm rule add "${MC_ALIAS}/${BUCKET}" \
  --id "delete-temp-files" \
  --expiry-days 7 \
  --prefix "tmp/"

# Example 3: Transition infrequent access data after 90 days
# Note: Requires tiered storage configuration
# mc ilm rule add "${MC_ALIAS}/${BUCKET}" \
#   --id "tier-old-data" \
#   --transition-days 90 \
#   --storage-class "GLACIER" \
#   --prefix "archive/"

# Example 4: Delete old versions after 30 days (requires versioning)
# mc ilm rule add "${MC_ALIAS}/${BUCKET}" \
#   --id "delete-old-versions" \
#   --noncurrentversion-expiration-days 30

echo ""
echo "Lifecycle rules configured. View with:"
echo "  mc ilm rule ls ${MC_ALIAS}/${BUCKET}"
`, bucketName, bucketName))
}

// BuildLifecycleRulesFromTags creates lifecycle rules based on common tagging patterns.
func BuildLifecycleRulesFromTags(tags map[string]string) []LifecycleRule {
	var rules []LifecycleRule

	// Check for retention tags
	if retention, ok := tags["retention"]; ok {
		var days int
		switch strings.ToLower(retention) {
		case "30d", "30days", "1month":
			days = 30
		case "90d", "90days", "3months":
			days = 90
		case "365d", "365days", "1year":
			days = 365
		case "7years":
			days = 2555
		}
		if days > 0 {
			rules = append(rules, LifecycleRule{
				ID:             "retention-policy",
				ExpirationDays: days,
				Enabled:        true,
			})
		}
	}

	// Check for log retention
	if logRetention, ok := tags["log-retention"]; ok {
		var days int
		switch strings.ToLower(logRetention) {
		case "7d", "7days", "1week":
			days = 7
		case "30d", "30days", "1month":
			days = 30
		case "90d", "90days", "3months":
			days = 90
		}
		if days > 0 {
			rules = append(rules, LifecycleRule{
				ID:             "log-retention",
				Prefix:         "logs/",
				ExpirationDays: days,
				Enabled:        true,
			})
		}
	}

	// Check for archive transition
	if archiveAfter, ok := tags["archive-after"]; ok {
		var days int
		switch strings.ToLower(archiveAfter) {
		case "30d", "30days":
			days = 30
		case "90d", "90days":
			days = 90
		case "180d", "180days":
			days = 180
		}
		if days > 0 {
			rules = append(rules, LifecycleRule{
				ID:      "archive-transition",
				Enabled: true,
				Transition: &TransitionRule{
					Days:         days,
					StorageClass: "GLACIER",
				},
			})
		}
	}

	return rules
}
