// Package objectstore provides shared utilities for object storage mapping.
package objectstore

import (
	"bytes"
	"fmt"
	"text/template"
)

// MinIOEncryptionEnvVars returns environment variables for MinIO SSE configuration.
// These variables should be set in the MinIO container environment.
func MinIOEncryptionEnvVars(opts *ObjectStoreOptions) map[string]string {
	if opts == nil || !opts.SSEEnabled {
		return map[string]string{}
	}

	envVars := map[string]string{
		// MinIO KMS configuration using local master key
		"MINIO_KMS_SECRET_KEY": "homeport-key:${MINIO_MASTER_KEY}",
	}

	return envVars
}

// MinIOEncryptionSetupScript returns mc commands to configure SSE on a bucket.
// The script uses MinIO Client (mc) to enable server-side encryption.
func MinIOEncryptionSetupScript(opts *ObjectStoreOptions) []byte {
	if opts == nil || !opts.SSEEnabled {
		return []byte{}
	}

	protocol := "http"
	if opts.TLSEnabled {
		protocol = "https"
	}

	tmpl := `#!/bin/bash
# MinIO Server-Side Encryption Setup Script
# Bucket: {{.BucketName}}
# Generated by Homeport
#
# This script configures SSE-S3 encryption for the specified bucket.
# It uses MinIO's native encryption with auto-generated keys.

set -e

# Configuration
BUCKET_NAME="{{.BucketName}}"
MINIO_ALIAS="local"
MINIO_ENDPOINT="{{.Protocol}}://localhost:9000"
MINIO_ROOT_USER="${MINIO_ROOT_USER:-minioadmin}"
MINIO_ROOT_PASSWORD="${MINIO_ROOT_PASSWORD:-minioadmin}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  MinIO Encryption Setup"
echo "========================================="
echo ""
echo "Bucket: $BUCKET_NAME"
echo "Endpoint: $MINIO_ENDPOINT"
echo ""

# Check if mc is installed
if ! command -v mc >/dev/null 2>&1; then
    log_error "MinIO Client (mc) is not installed"
    echo "Install with: curl -O https://dl.min.io/client/mc/release/linux-amd64/mc && chmod +x mc && mv mc /usr/local/bin/"
    exit 1
fi

# Configure MinIO alias
log_info "Configuring MinIO alias..."
{{if .TLSEnabled}}
mc alias set "$MINIO_ALIAS" "$MINIO_ENDPOINT" "$MINIO_ROOT_USER" "$MINIO_ROOT_PASSWORD" --insecure
{{else}}
mc alias set "$MINIO_ALIAS" "$MINIO_ENDPOINT" "$MINIO_ROOT_USER" "$MINIO_ROOT_PASSWORD"
{{end}}

# Create bucket if it doesn't exist
log_info "Ensuring bucket exists..."
{{if .TLSEnabled}}
mc mb --ignore-existing "${MINIO_ALIAS}/${BUCKET_NAME}" --insecure
{{else}}
mc mb --ignore-existing "${MINIO_ALIAS}/${BUCKET_NAME}"
{{end}}

# Enable SSE-S3 encryption on the bucket
log_info "Enabling SSE-S3 encryption..."
{{if .TLSEnabled}}
mc encrypt set sse-s3 "${MINIO_ALIAS}/${BUCKET_NAME}" --insecure
{{else}}
mc encrypt set sse-s3 "${MINIO_ALIAS}/${BUCKET_NAME}"
{{end}}

{{if .Versioning}}
# Enable versioning
log_info "Enabling bucket versioning..."
{{if .TLSEnabled}}
mc version enable "${MINIO_ALIAS}/${BUCKET_NAME}" --insecure
{{else}}
mc version enable "${MINIO_ALIAS}/${BUCKET_NAME}"
{{end}}
{{end}}

echo ""
echo "========================================="
echo "  Setup Complete"
echo "========================================="
echo ""
echo "Encryption: SSE-S3 enabled"
{{if .Versioning}}
echo "Versioning: Enabled"
{{end}}
{{if .CloudProvider}}
echo ""
echo "Original cloud source: {{.CloudProvider}}{{if .Region}} ({{.Region}}){{end}}"
{{end}}
`

	data := struct {
		BucketName    string
		Protocol      string
		TLSEnabled    bool
		Versioning    bool
		CloudProvider string
		Region        string
	}{
		BucketName:    opts.BucketName,
		Protocol:      protocol,
		TLSEnabled:    opts.TLSEnabled,
		Versioning:    opts.Versioning,
		CloudProvider: opts.CloudProvider,
		Region:        opts.Region,
	}

	t, err := template.New("minio-encryption").Parse(tmpl)
	if err != nil {
		return []byte(fmt.Sprintf("# Error parsing template: %v\n", err))
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return []byte(fmt.Sprintf("# Error executing template: %v\n", err))
	}

	return buf.Bytes()
}

// MinIOTLSSetupScript returns a script to setup TLS for MinIO.
// The script creates necessary directories and configures TLS certificates.
func MinIOTLSSetupScript(opts *ObjectStoreOptions) []byte {
	if opts == nil || !opts.TLSEnabled || opts.TLSOptions == nil {
		return []byte{}
	}

	tmpl := `#!/bin/bash
# MinIO TLS Setup Script
# Generated by Homeport
#
# This script configures TLS certificates for MinIO.

set -e

# Configuration
MINIO_CERTS_DIR="/var/lib/homeport/minio/certs"
CERT_PATH="{{.CertPath}}"
KEY_PATH="{{.KeyPath}}"
{{if .CAPath}}
CA_PATH="{{.CAPath}}"
{{end}}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  MinIO TLS Setup"
echo "========================================="
echo ""

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_warn "Running as non-root. Some operations may require sudo."
fi

# Create certificate directories
log_info "Creating certificate directories..."
mkdir -p "${MINIO_CERTS_DIR}"
mkdir -p "${MINIO_CERTS_DIR}/CAs"

# Copy certificates
if [ -f "$CERT_PATH" ]; then
    log_info "Copying TLS certificate..."
    cp "$CERT_PATH" "${MINIO_CERTS_DIR}/public.crt"
else
    log_error "Certificate file not found: $CERT_PATH"
    exit 1
fi

if [ -f "$KEY_PATH" ]; then
    log_info "Copying TLS private key..."
    cp "$KEY_PATH" "${MINIO_CERTS_DIR}/private.key"
    chmod 600 "${MINIO_CERTS_DIR}/private.key"
else
    log_error "Private key file not found: $KEY_PATH"
    exit 1
fi

{{if .CAPath}}
if [ -f "$CA_PATH" ]; then
    log_info "Copying CA certificate..."
    cp "$CA_PATH" "${MINIO_CERTS_DIR}/CAs/ca.crt"
else
    log_warn "CA certificate not found: $CA_PATH"
fi
{{end}}

# Set permissions
log_info "Setting permissions..."
chmod 644 "${MINIO_CERTS_DIR}/public.crt"
chmod 600 "${MINIO_CERTS_DIR}/private.key"

echo ""
echo "========================================="
echo "  TLS Setup Complete"
echo "========================================="
echo ""
echo "Certificate directory: ${MINIO_CERTS_DIR}"
echo ""
echo "To use with MinIO Docker container, mount the certs directory:"
echo "  docker run -v ${MINIO_CERTS_DIR}:/root/.minio/certs minio/minio server /data"
echo ""
echo "Or add to docker-compose.yml:"
echo "  volumes:"
echo "    - ${MINIO_CERTS_DIR}:/root/.minio/certs:ro"
`

	t, err := template.New("minio-tls").Parse(tmpl)
	if err != nil {
		return []byte(fmt.Sprintf("# Error parsing template: %v\n", err))
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, opts.TLSOptions); err != nil {
		return []byte(fmt.Sprintf("# Error executing template: %v\n", err))
	}

	return buf.Bytes()
}

// GenerateMasterKeyScript returns a script to generate a master encryption key.
// The key is used for MinIO's KMS configuration with local encryption.
func GenerateMasterKeyScript(keyPath string) []byte {
	if keyPath == "" {
		keyPath = "/var/lib/homeport/keys/minio-master.key"
	}

	return []byte(fmt.Sprintf(`#!/bin/bash
# MinIO Master Key Generation Script
# Generated by Homeport
#
# This script generates a secure master key for MinIO encryption.
# The key is used for SSE-S3 encryption with local key management.

set -e

# Configuration
KEY_PATH="%s"
KEY_DIR=$(dirname "$KEY_PATH")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  MinIO Master Key Generation"
echo "========================================="
echo ""

# Check if key already exists
if [ -f "$KEY_PATH" ]; then
    log_warn "Master key already exists at: $KEY_PATH"
    echo ""
    read -p "Do you want to overwrite it? (y/N) " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Keeping existing key."
        exit 0
    fi
    log_warn "Overwriting existing key..."
fi

# Create key directory
log_info "Creating key directory..."
mkdir -p "$KEY_DIR"
chmod 700 "$KEY_DIR"

# Generate a 32-byte (256-bit) random key and encode as base64
log_info "Generating master key..."
KEY_VALUE=$(openssl rand -base64 32 | tr -d '\n')

# Write key to file
echo "$KEY_VALUE" > "$KEY_PATH"
chmod 400 "$KEY_PATH"

echo ""
echo "========================================="
echo "  Key Generation Complete"
echo "========================================="
echo ""
echo "Key file: $KEY_PATH"
echo ""
log_warn "IMPORTANT: Backup this key securely!"
log_warn "Without it, encrypted data cannot be decrypted."
echo ""
echo "To use with MinIO, set the environment variable:"
echo "  export MINIO_MASTER_KEY=\$(cat $KEY_PATH)"
echo ""
echo "Or in docker-compose.yml:"
echo "  environment:"
echo "    - MINIO_KMS_SECRET_KEY=homeport-key:\${MINIO_MASTER_KEY}"
echo "  env_file:"
echo "    - .env  # Contains MINIO_MASTER_KEY=<key_value>"
`, keyPath))
}

// MinIOLifecycleSetupScript returns a script to configure lifecycle rules on a bucket.
func MinIOLifecycleSetupScript(opts *ObjectStoreOptions) []byte {
	if opts == nil || len(opts.LifecycleRules) == 0 {
		return []byte{}
	}

	protocol := "http"
	if opts.TLSEnabled {
		protocol = "https"
	}

	tmpl := `#!/bin/bash
# MinIO Lifecycle Rules Setup Script
# Bucket: {{.BucketName}}
# Generated by Homeport
#
# This script configures lifecycle rules for the specified bucket.

set -e

# Configuration
BUCKET_NAME="{{.BucketName}}"
MINIO_ALIAS="local"
MINIO_ENDPOINT="{{.Protocol}}://localhost:9000"
MINIO_ROOT_USER="${MINIO_ROOT_USER:-minioadmin}"
MINIO_ROOT_PASSWORD="${MINIO_ROOT_PASSWORD:-minioadmin}"

# Colors for output
GREEN='\033[0;32m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

echo "========================================="
echo "  MinIO Lifecycle Rules Setup"
echo "========================================="
echo ""

# Configure MinIO alias
log_info "Configuring MinIO alias..."
{{if .TLSEnabled}}
mc alias set "$MINIO_ALIAS" "$MINIO_ENDPOINT" "$MINIO_ROOT_USER" "$MINIO_ROOT_PASSWORD" --insecure
{{else}}
mc alias set "$MINIO_ALIAS" "$MINIO_ENDPOINT" "$MINIO_ROOT_USER" "$MINIO_ROOT_PASSWORD"
{{end}}

# Configure lifecycle rules
{{range .LifecycleRules}}
log_info "Adding lifecycle rule: {{.ID}}..."
{{if $.TLSEnabled}}
mc ilm rule add "${MINIO_ALIAS}/${BUCKET_NAME}" \
    --id "{{.ID}}" \
    {{if .Prefix}}--prefix "{{.Prefix}}" \{{end}}
    {{if gt .ExpirationDays 0}}--expire-days {{.ExpirationDays}} \{{end}}
    {{if .Transition}}--transition-days {{.Transition.Days}} --transition-tier "{{.Transition.StorageClass}}" \{{end}}
    --insecure
{{else}}
mc ilm rule add "${MINIO_ALIAS}/${BUCKET_NAME}" \
    --id "{{.ID}}" \
    {{if .Prefix}}--prefix "{{.Prefix}}" \{{end}}
    {{if gt .ExpirationDays 0}}--expire-days {{.ExpirationDays}}{{end}}
    {{if .Transition}}--transition-days {{.Transition.Days}} --transition-tier "{{.Transition.StorageClass}}"{{end}}

{{end}}
{{end}}

echo ""
echo "========================================="
echo "  Lifecycle Rules Setup Complete"
echo "========================================="
echo ""
log_info "Configured {{len .LifecycleRules}} lifecycle rule(s)"
`

	data := struct {
		BucketName     string
		Protocol       string
		TLSEnabled     bool
		LifecycleRules []LifecycleRule
	}{
		BucketName:     opts.BucketName,
		Protocol:       protocol,
		TLSEnabled:     opts.TLSEnabled,
		LifecycleRules: opts.LifecycleRules,
	}

	t, err := template.New("minio-lifecycle").Parse(tmpl)
	if err != nil {
		return []byte(fmt.Sprintf("# Error parsing template: %v\n", err))
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return []byte(fmt.Sprintf("# Error executing template: %v\n", err))
	}

	return buf.Bytes()
}
