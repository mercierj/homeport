// Package database provides shared utilities for database mappers.
package database

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/homeport/homeport/internal/infrastructure/mapper/shared/tls"
)

// PostgresTLSScript returns script to configure PostgreSQL TLS.
func PostgresTLSScript(opts *DatabaseOptions) []byte {
	if opts == nil || !opts.TLSEnabled || opts.TLSOptions == nil {
		return []byte("# TLS not enabled for this database\n")
	}

	tmpl := `#!/bin/bash
# PostgreSQL TLS Setup
# Database: {{.Name}}
# Generated by Homeport
#
# This script sets up TLS certificates for PostgreSQL.

set -e

# Configuration
CERT_DIR="./certs/postgres"
CA_DIR="./certs/ca"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  PostgreSQL TLS Setup"
echo "========================================="
echo ""

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_warn "Not running as root. Some operations may fail."
fi

# Create directories
log_info "Creating certificate directories..."
mkdir -p ${CERT_DIR}
mkdir -p ${CA_DIR}

# Check if CA certificates exist
if [ ! -f "${CA_DIR}/ca.crt" ]; then
    log_info "Generating CA certificate..."
    openssl genrsa -out ${CA_DIR}/ca.key 4096
    openssl req -new -x509 -days 3650 -key ${CA_DIR}/ca.key \
        -out ${CA_DIR}/ca.crt \
        -subj "/CN=Homeport-CA/O=Homeport/C=US"
    log_warn "CA certificate generated. In production, use a proper CA."
fi

# Copy CA cert to postgres directory
cp ${CA_DIR}/ca.crt ${CERT_DIR}/

# Generate server certificate if it doesn't exist
if [ ! -f "${CERT_DIR}/server.crt" ]; then
    log_info "Generating server certificate..."

    # Generate server key
    openssl genrsa -out ${CERT_DIR}/server.key 2048

    # Create CSR
    openssl req -new -key ${CERT_DIR}/server.key \
        -out ${CERT_DIR}/server.csr \
        -subj "/CN={{.Name}}/O=Homeport/C=US"

    # Sign with CA
    openssl x509 -req -days 365 \
        -in ${CERT_DIR}/server.csr \
        -CA ${CA_DIR}/ca.crt \
        -CAkey ${CA_DIR}/ca.key \
        -CAcreateserial \
        -out ${CERT_DIR}/server.crt

    # Clean up CSR
    rm -f ${CERT_DIR}/server.csr

    log_info "Server certificate generated."
else
    log_info "Server certificate already exists."
fi

# Set permissions
log_info "Setting file permissions..."
chmod 600 ${CERT_DIR}/server.key
chmod 644 ${CERT_DIR}/server.crt ${CERT_DIR}/ca.crt
chown -R 999:999 ${CERT_DIR}  # postgres user

echo ""
echo "========================================="
echo "  Setup Complete"
echo "========================================="
echo ""
echo "Certificates generated in: ${CERT_DIR}"
echo ""
echo "To verify the certificate:"
echo "  openssl x509 -in ${CERT_DIR}/server.crt -text -noout"
echo ""
log_warn "Remember to backup your CA key securely!"
log_warn "In production, use certificates from a trusted CA."
`

	t, err := template.New("postgres-tls-setup").Parse(tmpl)
	if err != nil {
		return []byte(fmt.Sprintf("# Error parsing template: %v\n", err))
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, opts); err != nil {
		return []byte(fmt.Sprintf("# Error executing template: %v\n", err))
	}

	return buf.Bytes()
}

// PostgresTLSConfig returns postgresql.conf TLS settings.
func PostgresTLSConfig(opts *DatabaseOptions) []byte {
	if opts == nil || !opts.TLSEnabled || opts.TLSOptions == nil {
		return []byte("# TLS not enabled\n")
	}

	tlsOpts := opts.TLSOptions
	certDir := tlsOpts.CertDir
	if certDir == "" {
		certDir = "/var/lib/postgresql/certs"
	}

	minVersion := tlsOpts.MinProtocolVersion
	if minVersion == "" {
		minVersion = "TLSv1.2"
	}

	ciphers := tlsOpts.Ciphers
	if ciphers == "" {
		ciphers = "HIGH:MEDIUM:+3DES:!aNULL"
	}

	preferServer := "on"
	if !tlsOpts.PreferServerCiphers {
		preferServer = "off"
	}

	config := fmt.Sprintf(`# TLS Configuration
# Generated by Homeport for database: %s
ssl = on
ssl_cert_file = '%s/server.crt'
ssl_key_file = '%s/server.key'
ssl_ca_file = '%s/ca.crt'
ssl_ciphers = '%s'
ssl_prefer_server_ciphers = %s
ssl_min_protocol_version = '%s'
`, opts.Name, certDir, certDir, certDir, ciphers, preferServer, minVersion)

	return []byte(config)
}

// PostgresHBAConfig returns pg_hba.conf with SSL enforcement.
func PostgresHBAConfig(opts *DatabaseOptions) []byte {
	if opts == nil || !opts.TLSEnabled || opts.TLSOptions == nil {
		return []byte(`# TYPE  DATABASE  USER  ADDRESS       METHOD
host    all       all   0.0.0.0/0     scram-sha-256
host    all       all   ::/0          scram-sha-256
local   all       all                 peer
`)
	}

	authMethod := "scram-sha-256"
	if opts.TLSOptions.RequireClientCerts {
		authMethod = "cert"
	}

	config := fmt.Sprintf(`# pg_hba.conf with SSL enforcement
# Generated by Homeport for database: %s
# TYPE  DATABASE  USER  ADDRESS       METHOD
hostssl all       all   0.0.0.0/0     %s
hostssl all       all   ::/0          %s
local   all       all                 peer
`, opts.Name, authMethod, authMethod)

	return []byte(config)
}

// PostgresCertVolumes returns volume mounts for TLS certs.
func PostgresCertVolumes(opts *DatabaseOptions) []string {
	if opts == nil || !opts.TLSEnabled || opts.TLSOptions == nil {
		return nil
	}

	certDir := opts.TLSOptions.CertDir
	if certDir == "" {
		certDir = "/var/lib/postgresql/certs"
	}

	return []string{
		fmt.Sprintf("./certs/postgres/server.crt:%s/server.crt:ro", certDir),
		fmt.Sprintf("./certs/postgres/server.key:%s/server.key:ro", certDir),
		fmt.Sprintf("./certs/postgres/ca.crt:%s/ca.crt:ro", certDir),
	}
}

// MySQLTLSScript returns script to configure MySQL TLS.
func MySQLTLSScript(opts *DatabaseOptions) []byte {
	if opts == nil || !opts.TLSEnabled || opts.TLSOptions == nil {
		return []byte("# TLS not enabled for this database\n")
	}

	tmpl := `#!/bin/bash
# MySQL TLS Setup
# Database: {{.Name}}
# Generated by Homeport
#
# This script sets up TLS certificates for MySQL.

set -e

# Configuration
CERT_DIR="./certs/mysql"
CA_DIR="./certs/ca"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  MySQL TLS Setup"
echo "========================================="
echo ""

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_warn "Not running as root. Some operations may fail."
fi

# Create directories
log_info "Creating certificate directories..."
mkdir -p ${CERT_DIR}
mkdir -p ${CA_DIR}

# Check if CA certificates exist
if [ ! -f "${CA_DIR}/ca.crt" ]; then
    log_info "Generating CA certificate..."
    openssl genrsa -out ${CA_DIR}/ca.key 4096
    openssl req -new -x509 -days 3650 -key ${CA_DIR}/ca.key \
        -out ${CA_DIR}/ca.crt \
        -subj "/CN=Homeport-CA/O=Homeport/C=US"
    log_warn "CA certificate generated. In production, use a proper CA."
fi

# Copy CA cert to mysql directory
cp ${CA_DIR}/ca.crt ${CERT_DIR}/

# Generate server certificate if it doesn't exist
if [ ! -f "${CERT_DIR}/server.crt" ]; then
    log_info "Generating server certificate..."

    # Generate server key
    openssl genrsa -out ${CERT_DIR}/server.key 2048

    # Create CSR
    openssl req -new -key ${CERT_DIR}/server.key \
        -out ${CERT_DIR}/server.csr \
        -subj "/CN={{.Name}}/O=Homeport/C=US"

    # Sign with CA
    openssl x509 -req -days 365 \
        -in ${CERT_DIR}/server.csr \
        -CA ${CA_DIR}/ca.crt \
        -CAkey ${CA_DIR}/ca.key \
        -CAcreateserial \
        -out ${CERT_DIR}/server.crt

    # Clean up CSR
    rm -f ${CERT_DIR}/server.csr

    log_info "Server certificate generated."
else
    log_info "Server certificate already exists."
fi

# Set permissions (MySQL requires specific permissions)
log_info "Setting file permissions..."
chmod 600 ${CERT_DIR}/server.key
chmod 644 ${CERT_DIR}/server.crt ${CERT_DIR}/ca.crt
chown -R 999:999 ${CERT_DIR}  # mysql user

echo ""
echo "========================================="
echo "  Setup Complete"
echo "========================================="
echo ""
echo "Certificates generated in: ${CERT_DIR}"
echo ""
echo "To verify the certificate:"
echo "  openssl x509 -in ${CERT_DIR}/server.crt -text -noout"
echo ""
echo "To verify MySQL is using SSL, connect and run:"
echo "  SHOW VARIABLES LIKE '%ssl%';"
echo ""
log_warn "Remember to backup your CA key securely!"
log_warn "In production, use certificates from a trusted CA."
`

	t, err := template.New("mysql-tls-setup").Parse(tmpl)
	if err != nil {
		return []byte(fmt.Sprintf("# Error parsing template: %v\n", err))
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, opts); err != nil {
		return []byte(fmt.Sprintf("# Error executing template: %v\n", err))
	}

	return buf.Bytes()
}

// MySQLTLSConfig returns my.cnf TLS settings.
func MySQLTLSConfig(opts *DatabaseOptions) []byte {
	if opts == nil || !opts.TLSEnabled || opts.TLSOptions == nil {
		return []byte("# TLS not enabled\n")
	}

	tlsOpts := opts.TLSOptions
	certDir := tlsOpts.CertDir
	if certDir == "" {
		certDir = "/etc/mysql/certs"
	}

	minVersion := tlsOpts.MinProtocolVersion
	if minVersion == "" {
		minVersion = "TLSv1.2"
	}

	// Convert version format for MySQL (TLSv1.2 -> TLSv1.2,TLSv1.3)
	tlsVersions := minVersion
	if minVersion == "TLSv1.2" {
		tlsVersions = "TLSv1.2,TLSv1.3"
	} else if minVersion == "TLSv1.3" {
		tlsVersions = "TLSv1.3"
	}

	requireSecure := "ON"
	if !tlsOpts.EnforceSSLConnection {
		requireSecure = "OFF"
	}

	config := fmt.Sprintf(`[mysqld]
# TLS Configuration
# Generated by Homeport for database: %s
require_secure_transport = %s
ssl-ca = %s/ca.crt
ssl-cert = %s/server.crt
ssl-key = %s/server.key
tls_version = %s
`, opts.Name, requireSecure, certDir, certDir, certDir, tlsVersions)

	if tlsOpts.RequireClientCerts {
		config += "ssl-verify-server-cert = ON\n"
	}

	return []byte(config)
}

// MySQLCertVolumes returns volume mounts for TLS certs.
func MySQLCertVolumes(opts *DatabaseOptions) []string {
	if opts == nil || !opts.TLSEnabled || opts.TLSOptions == nil {
		return nil
	}

	certDir := opts.TLSOptions.CertDir
	if certDir == "" {
		certDir = "/etc/mysql/certs"
	}

	return []string{
		fmt.Sprintf("./certs/mysql/server.crt:%s/server.crt:ro", certDir),
		fmt.Sprintf("./certs/mysql/server.key:%s/server.key:ro", certDir),
		fmt.Sprintf("./certs/mysql/ca.crt:%s/ca.crt:ro", certDir),
	}
}

// SetPostgresTLSDefaults configures default TLS settings for PostgreSQL.
func SetPostgresTLSDefaults(opts *DatabaseOptions) {
	if opts == nil {
		return
	}
	opts.TLSEnabled = true
	opts.TLSOptions = tls.NewTLSOptions(opts.Name).
		WithCertDir("/var/lib/postgresql/certs")
}

// SetMySQLTLSDefaults configures default TLS settings for MySQL.
func SetMySQLTLSDefaults(opts *DatabaseOptions) {
	if opts == nil {
		return
	}
	opts.TLSEnabled = true
	opts.TLSOptions = tls.NewTLSOptions(opts.Name).
		WithCertDir("/etc/mysql/certs")
}
