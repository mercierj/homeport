// Package database provides shared utilities for database mapping.
package database

import (
	"fmt"
	"strconv"
	"time"

	"github.com/homeport/homeport/internal/domain/mapper"
)

// BackupOptions contains configuration options for database backup.
type BackupOptions struct {
	// Name is the database name
	Name string

	// Engine is the database engine (postgres, mysql, mariadb)
	Engine string

	// Version is the database version
	Version string

	// BackupDir is the directory to store backups
	BackupDir string

	// RetentionDays is the number of days to keep backups
	RetentionDays int

	// EncryptionEnabled enables backup encryption
	EncryptionEnabled bool

	// EncryptionKey is the encryption key (or environment variable name)
	EncryptionKey string

	// CompressionEnabled enables backup compression
	CompressionEnabled bool

	// CompressionLevel is the gzip compression level (1-9)
	CompressionLevel int

	// Schedule is the cron schedule for backups
	Schedule string

	// PrimaryHost is the hostname of the database to backup
	PrimaryHost string

	// User is the database user for backups
	User string

	// Password is the database password
	Password string
}

// DefaultBackupOptions returns default options for database backup.
func DefaultBackupOptions(name, engine string) *BackupOptions {
	return &BackupOptions{
		Name:               name,
		Engine:             engine,
		Version:            "16",
		BackupDir:          "./backups/" + engine,
		RetentionDays:      7,
		EncryptionEnabled:  true,
		EncryptionKey:      "BACKUP_ENCRYPTION_KEY",
		CompressionEnabled: true,
		CompressionLevel:   6,
		Schedule:           "0 2 * * *", // 2 AM daily
		PrimaryHost:        name,
		User:               "postgres",
		Password:           "changeme",
	}
}

// DatabaseBackupScript returns encrypted backup script.
func DatabaseBackupScript(opts *BackupOptions) []byte {
	if opts == nil {
		opts = DefaultBackupOptions("postgres", "postgres")
	}

	switch opts.Engine {
	case "mysql", "mariadb":
		return mysqlBackupScript(opts)
	default:
		return postgresBackupScript(opts)
	}
}

// postgresBackupScript returns PostgreSQL backup script.
func postgresBackupScript(opts *BackupOptions) []byte {
	backupDir := opts.BackupDir
	if backupDir == "" {
		backupDir = "./backups/postgres"
	}

	retentionDays := opts.RetentionDays
	if retentionDays == 0 {
		retentionDays = 7
	}

	dbName := opts.Name
	if dbName == "" {
		dbName = "postgres"
	}

	host := opts.PrimaryHost
	if host == "" {
		host = "postgres"
	}

	user := opts.User
	if user == "" {
		user = "postgres"
	}

	script := fmt.Sprintf(`#!/bin/bash
# Encrypted PostgreSQL Backup Script
# Generated by Homeport
# ============================================================================
set -e

# ============================================================================
# Configuration
# ============================================================================
BACKUP_DIR=${BACKUP_DIR:-%s}
RETENTION_DAYS=${RETENTION_DAYS:-%d}
ENCRYPTION_KEY=${BACKUP_ENCRYPTION_KEY:-}
DB_NAME=${POSTGRES_DB:-%s}
DB_HOST=${POSTGRES_HOST:-%s}
DB_USER=${POSTGRES_USER:-%s}
DB_PASSWORD=${POSTGRES_PASSWORD:-changeme}
TIMESTAMP=$(date +%%Y%%m%%d_%%H%%M%%S)

echo "=========================================="
echo "PostgreSQL Backup"
echo "=========================================="
echo "Database: ${DB_NAME}"
echo "Host: ${DB_HOST}"
echo "Backup Directory: ${BACKUP_DIR}"
echo "Retention: ${RETENTION_DAYS} days"
echo "Timestamp: ${TIMESTAMP}"
echo ""

# ============================================================================
# Create backup directory
# ============================================================================
mkdir -p ${BACKUP_DIR}

# ============================================================================
# Wait for database to be ready
# ============================================================================
echo "[1/5] Waiting for database to be ready..."
until PGPASSWORD=${DB_PASSWORD} pg_isready -h ${DB_HOST} -U ${DB_USER} -q; do
  echo "  - Database not ready, retrying in 2 seconds..."
  sleep 2
done
echo "  - Database is ready!"

# ============================================================================
# Create backup
# ============================================================================
echo "[2/5] Creating backup..."
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${TIMESTAMP}.sql"

PGPASSWORD=${DB_PASSWORD} pg_dump \
  -h ${DB_HOST} \
  -U ${DB_USER} \
  -d ${DB_NAME} \
  --no-owner \
  --no-acl \
  --clean \
  --if-exists \
  > ${BACKUP_FILE}

BACKUP_SIZE=$(du -h ${BACKUP_FILE} | cut -f1)
echo "  - Backup created: ${BACKUP_FILE} (${BACKUP_SIZE})"

# ============================================================================
# Encrypt if key provided
# ============================================================================
if [ -n "${ENCRYPTION_KEY}" ]; then
  echo "[3/5] Encrypting backup..."
  openssl enc -aes-256-cbc -salt -pbkdf2 -iter 100000 \
    -in ${BACKUP_FILE} \
    -out ${BACKUP_FILE}.enc \
    -pass env:BACKUP_ENCRYPTION_KEY

  rm ${BACKUP_FILE}
  BACKUP_FILE="${BACKUP_FILE}.enc"
  echo "  - Backup encrypted!"
else
  echo "[3/5] Skipping encryption (no key provided)"
fi

# ============================================================================
# Compress backup
# ============================================================================
echo "[4/5] Compressing backup..."
gzip -f ${BACKUP_FILE}
BACKUP_FILE="${BACKUP_FILE}.gz"
FINAL_SIZE=$(du -h ${BACKUP_FILE} | cut -f1)
echo "  - Compressed to: ${FINAL_SIZE}"

# ============================================================================
# Cleanup old backups
# ============================================================================
echo "[5/5] Cleaning up old backups..."
DELETED_COUNT=$(find ${BACKUP_DIR} -name "${DB_NAME}_*.sql*" -mtime +${RETENTION_DAYS} -type f | wc -l)
find ${BACKUP_DIR} -name "${DB_NAME}_*.sql*" -mtime +${RETENTION_DAYS} -type f -delete
echo "  - Deleted ${DELETED_COUNT} old backup(s)"

# ============================================================================
# Summary
# ============================================================================
echo ""
echo "=========================================="
echo "Backup Complete!"
echo "=========================================="
echo "File: ${BACKUP_FILE}"
echo "Size: ${FINAL_SIZE}"
echo ""
echo "To restore this backup:"
if [ -n "${ENCRYPTION_KEY}" ]; then
  echo "  1. Decrypt: openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 -in backup.sql.enc.gz -out backup.sql.gz -pass env:BACKUP_ENCRYPTION_KEY"
  echo "  2. Decompress: gunzip backup.sql.gz"
  echo "  3. Restore: psql -h host -U user -d database < backup.sql"
else
  echo "  1. Decompress: gunzip backup.sql.gz"
  echo "  2. Restore: psql -h host -U user -d database < backup.sql"
fi
`, backupDir, retentionDays, dbName, host, user)

	return []byte(script)
}

// mysqlBackupScript returns MySQL backup script.
func mysqlBackupScript(opts *BackupOptions) []byte {
	backupDir := opts.BackupDir
	if backupDir == "" {
		backupDir = "./backups/mysql"
	}

	retentionDays := opts.RetentionDays
	if retentionDays == 0 {
		retentionDays = 7
	}

	dbName := opts.Name
	if dbName == "" {
		dbName = "mysql"
	}

	host := opts.PrimaryHost
	if host == "" {
		host = "mysql"
	}

	user := opts.User
	if user == "" {
		user = "root"
	}

	script := fmt.Sprintf(`#!/bin/bash
# Encrypted MySQL Backup Script
# Generated by Homeport
# ============================================================================
set -e

# ============================================================================
# Configuration
# ============================================================================
BACKUP_DIR=${BACKUP_DIR:-%s}
RETENTION_DAYS=${RETENTION_DAYS:-%d}
ENCRYPTION_KEY=${BACKUP_ENCRYPTION_KEY:-}
DB_NAME=${MYSQL_DATABASE:-%s}
DB_HOST=${MYSQL_HOST:-%s}
DB_USER=${MYSQL_USER:-%s}
DB_PASSWORD=${MYSQL_PASSWORD:-changeme}
TIMESTAMP=$(date +%%Y%%m%%d_%%H%%M%%S)

echo "=========================================="
echo "MySQL Backup"
echo "=========================================="
echo "Database: ${DB_NAME}"
echo "Host: ${DB_HOST}"
echo "Backup Directory: ${BACKUP_DIR}"
echo "Retention: ${RETENTION_DAYS} days"
echo "Timestamp: ${TIMESTAMP}"
echo ""

# ============================================================================
# Create backup directory
# ============================================================================
mkdir -p ${BACKUP_DIR}

# ============================================================================
# Wait for database to be ready
# ============================================================================
echo "[1/5] Waiting for database to be ready..."
until mysqladmin -h ${DB_HOST} -u ${DB_USER} -p${DB_PASSWORD} ping --silent 2>/dev/null; do
  echo "  - Database not ready, retrying in 2 seconds..."
  sleep 2
done
echo "  - Database is ready!"

# ============================================================================
# Create backup
# ============================================================================
echo "[2/5] Creating backup..."
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${TIMESTAMP}.sql"

mysqldump \
  -h ${DB_HOST} \
  -u ${DB_USER} \
  -p${DB_PASSWORD} \
  --databases ${DB_NAME} \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  --set-gtid-purged=OFF \
  > ${BACKUP_FILE}

BACKUP_SIZE=$(du -h ${BACKUP_FILE} | cut -f1)
echo "  - Backup created: ${BACKUP_FILE} (${BACKUP_SIZE})"

# ============================================================================
# Encrypt if key provided
# ============================================================================
if [ -n "${ENCRYPTION_KEY}" ]; then
  echo "[3/5] Encrypting backup..."
  openssl enc -aes-256-cbc -salt -pbkdf2 -iter 100000 \
    -in ${BACKUP_FILE} \
    -out ${BACKUP_FILE}.enc \
    -pass env:BACKUP_ENCRYPTION_KEY

  rm ${BACKUP_FILE}
  BACKUP_FILE="${BACKUP_FILE}.enc"
  echo "  - Backup encrypted!"
else
  echo "[3/5] Skipping encryption (no key provided)"
fi

# ============================================================================
# Compress backup
# ============================================================================
echo "[4/5] Compressing backup..."
gzip -f ${BACKUP_FILE}
BACKUP_FILE="${BACKUP_FILE}.gz"
FINAL_SIZE=$(du -h ${BACKUP_FILE} | cut -f1)
echo "  - Compressed to: ${FINAL_SIZE}"

# ============================================================================
# Cleanup old backups
# ============================================================================
echo "[5/5] Cleaning up old backups..."
DELETED_COUNT=$(find ${BACKUP_DIR} -name "${DB_NAME}_*.sql*" -mtime +${RETENTION_DAYS} -type f | wc -l)
find ${BACKUP_DIR} -name "${DB_NAME}_*.sql*" -mtime +${RETENTION_DAYS} -type f -delete
echo "  - Deleted ${DELETED_COUNT} old backup(s)"

# ============================================================================
# Summary
# ============================================================================
echo ""
echo "=========================================="
echo "Backup Complete!"
echo "=========================================="
echo "File: ${BACKUP_FILE}"
echo "Size: ${FINAL_SIZE}"
echo ""
echo "To restore this backup:"
if [ -n "${ENCRYPTION_KEY}" ]; then
  echo "  1. Decrypt: openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 -in backup.sql.enc.gz -out backup.sql.gz -pass env:BACKUP_ENCRYPTION_KEY"
  echo "  2. Decompress: gunzip backup.sql.gz"
  echo "  3. Restore: mysql -h host -u user -p database < backup.sql"
else
  echo "  1. Decompress: gunzip backup.sql.gz"
  echo "  2. Restore: mysql -h host -u user -p database < backup.sql"
fi
`, backupDir, retentionDays, dbName, host, user)

	return []byte(script)
}

// DatabaseRestoreScript returns restore script.
func DatabaseRestoreScript(opts *BackupOptions) []byte {
	if opts == nil {
		opts = DefaultBackupOptions("postgres", "postgres")
	}

	switch opts.Engine {
	case "mysql", "mariadb":
		return mysqlRestoreScript(opts)
	default:
		return postgresRestoreScript(opts)
	}
}

// postgresRestoreScript returns PostgreSQL restore script.
func postgresRestoreScript(opts *BackupOptions) []byte {
	dbName := opts.Name
	if dbName == "" {
		dbName = "postgres"
	}

	host := opts.PrimaryHost
	if host == "" {
		host = "postgres"
	}

	user := opts.User
	if user == "" {
		user = "postgres"
	}

	script := fmt.Sprintf(`#!/bin/bash
# PostgreSQL Restore Script
# Generated by Homeport
# ============================================================================
set -e

# ============================================================================
# Configuration
# ============================================================================
BACKUP_FILE=${1:-}
ENCRYPTION_KEY=${BACKUP_ENCRYPTION_KEY:-}
DB_NAME=${POSTGRES_DB:-%s}
DB_HOST=${POSTGRES_HOST:-%s}
DB_USER=${POSTGRES_USER:-%s}
DB_PASSWORD=${POSTGRES_PASSWORD:-changeme}

if [ -z "${BACKUP_FILE}" ]; then
  echo "Usage: $0 <backup_file>"
  echo ""
  echo "Example:"
  echo "  $0 ./backups/postgres/mydb_20240101_020000.sql.enc.gz"
  exit 1
fi

if [ ! -f "${BACKUP_FILE}" ]; then
  echo "Error: Backup file not found: ${BACKUP_FILE}"
  exit 1
fi

echo "=========================================="
echo "PostgreSQL Restore"
echo "=========================================="
echo "Database: ${DB_NAME}"
echo "Host: ${DB_HOST}"
echo "Backup File: ${BACKUP_FILE}"
echo ""

# ============================================================================
# Wait for database to be ready
# ============================================================================
echo "[1/4] Waiting for database to be ready..."
until PGPASSWORD=${DB_PASSWORD} pg_isready -h ${DB_HOST} -U ${DB_USER} -q; do
  echo "  - Database not ready, retrying in 2 seconds..."
  sleep 2
done
echo "  - Database is ready!"

# ============================================================================
# Prepare backup file
# ============================================================================
echo "[2/4] Preparing backup file..."
WORK_FILE="${BACKUP_FILE}"

# Decompress if needed
if [[ "${WORK_FILE}" == *.gz ]]; then
  echo "  - Decompressing..."
  DECOMPRESSED_FILE="${WORK_FILE%%.gz}"
  gunzip -c "${WORK_FILE}" > "${DECOMPRESSED_FILE}"
  WORK_FILE="${DECOMPRESSED_FILE}"
fi

# Decrypt if needed
if [[ "${WORK_FILE}" == *.enc ]]; then
  if [ -z "${ENCRYPTION_KEY}" ]; then
    echo "Error: Backup is encrypted but BACKUP_ENCRYPTION_KEY is not set"
    exit 1
  fi
  echo "  - Decrypting..."
  DECRYPTED_FILE="${WORK_FILE%%.enc}"
  openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 \
    -in "${WORK_FILE}" \
    -out "${DECRYPTED_FILE}" \
    -pass env:BACKUP_ENCRYPTION_KEY

  # Clean up intermediate file if we created it
  if [[ "${WORK_FILE}" != "${BACKUP_FILE}" ]]; then
    rm -f "${WORK_FILE}"
  fi
  WORK_FILE="${DECRYPTED_FILE}"
fi

echo "  - Prepared: ${WORK_FILE}"

# ============================================================================
# Confirm restore
# ============================================================================
echo ""
echo "WARNING: This will overwrite the current database!"
read -p "Are you sure you want to continue? (yes/no): " CONFIRM
if [ "${CONFIRM}" != "yes" ]; then
  echo "Restore cancelled."
  # Cleanup
  if [[ "${WORK_FILE}" != "${BACKUP_FILE}" ]]; then
    rm -f "${WORK_FILE}"
  fi
  exit 0
fi

# ============================================================================
# Restore database
# ============================================================================
echo "[3/4] Restoring database..."
PGPASSWORD=${DB_PASSWORD} psql \
  -h ${DB_HOST} \
  -U ${DB_USER} \
  -d ${DB_NAME} \
  -f "${WORK_FILE}"
echo "  - Database restored!"

# ============================================================================
# Cleanup
# ============================================================================
echo "[4/4] Cleaning up..."
if [[ "${WORK_FILE}" != "${BACKUP_FILE}" ]]; then
  rm -f "${WORK_FILE}"
fi
echo "  - Cleanup complete!"

echo ""
echo "=========================================="
echo "Restore Complete!"
echo "=========================================="
`, dbName, host, user)

	return []byte(script)
}

// mysqlRestoreScript returns MySQL restore script.
func mysqlRestoreScript(opts *BackupOptions) []byte {
	dbName := opts.Name
	if dbName == "" {
		dbName = "mysql"
	}

	host := opts.PrimaryHost
	if host == "" {
		host = "mysql"
	}

	user := opts.User
	if user == "" {
		user = "root"
	}

	script := fmt.Sprintf(`#!/bin/bash
# MySQL Restore Script
# Generated by Homeport
# ============================================================================
set -e

# ============================================================================
# Configuration
# ============================================================================
BACKUP_FILE=${1:-}
ENCRYPTION_KEY=${BACKUP_ENCRYPTION_KEY:-}
DB_NAME=${MYSQL_DATABASE:-%s}
DB_HOST=${MYSQL_HOST:-%s}
DB_USER=${MYSQL_USER:-%s}
DB_PASSWORD=${MYSQL_PASSWORD:-changeme}

if [ -z "${BACKUP_FILE}" ]; then
  echo "Usage: $0 <backup_file>"
  echo ""
  echo "Example:"
  echo "  $0 ./backups/mysql/mydb_20240101_020000.sql.enc.gz"
  exit 1
fi

if [ ! -f "${BACKUP_FILE}" ]; then
  echo "Error: Backup file not found: ${BACKUP_FILE}"
  exit 1
fi

echo "=========================================="
echo "MySQL Restore"
echo "=========================================="
echo "Database: ${DB_NAME}"
echo "Host: ${DB_HOST}"
echo "Backup File: ${BACKUP_FILE}"
echo ""

# ============================================================================
# Wait for database to be ready
# ============================================================================
echo "[1/4] Waiting for database to be ready..."
until mysqladmin -h ${DB_HOST} -u ${DB_USER} -p${DB_PASSWORD} ping --silent 2>/dev/null; do
  echo "  - Database not ready, retrying in 2 seconds..."
  sleep 2
done
echo "  - Database is ready!"

# ============================================================================
# Prepare backup file
# ============================================================================
echo "[2/4] Preparing backup file..."
WORK_FILE="${BACKUP_FILE}"

# Decompress if needed
if [[ "${WORK_FILE}" == *.gz ]]; then
  echo "  - Decompressing..."
  DECOMPRESSED_FILE="${WORK_FILE%%.gz}"
  gunzip -c "${WORK_FILE}" > "${DECOMPRESSED_FILE}"
  WORK_FILE="${DECOMPRESSED_FILE}"
fi

# Decrypt if needed
if [[ "${WORK_FILE}" == *.enc ]]; then
  if [ -z "${ENCRYPTION_KEY}" ]; then
    echo "Error: Backup is encrypted but BACKUP_ENCRYPTION_KEY is not set"
    exit 1
  fi
  echo "  - Decrypting..."
  DECRYPTED_FILE="${WORK_FILE%%.enc}"
  openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 \
    -in "${WORK_FILE}" \
    -out "${DECRYPTED_FILE}" \
    -pass env:BACKUP_ENCRYPTION_KEY

  # Clean up intermediate file if we created it
  if [[ "${WORK_FILE}" != "${BACKUP_FILE}" ]]; then
    rm -f "${WORK_FILE}"
  fi
  WORK_FILE="${DECRYPTED_FILE}"
fi

echo "  - Prepared: ${WORK_FILE}"

# ============================================================================
# Confirm restore
# ============================================================================
echo ""
echo "WARNING: This will overwrite the current database!"
read -p "Are you sure you want to continue? (yes/no): " CONFIRM
if [ "${CONFIRM}" != "yes" ]; then
  echo "Restore cancelled."
  # Cleanup
  if [[ "${WORK_FILE}" != "${BACKUP_FILE}" ]]; then
    rm -f "${WORK_FILE}"
  fi
  exit 0
fi

# ============================================================================
# Restore database
# ============================================================================
echo "[3/4] Restoring database..."
mysql \
  -h ${DB_HOST} \
  -u ${DB_USER} \
  -p${DB_PASSWORD} \
  < "${WORK_FILE}"
echo "  - Database restored!"

# ============================================================================
# Cleanup
# ============================================================================
echo "[4/4] Cleaning up..."
if [[ "${WORK_FILE}" != "${BACKUP_FILE}" ]]; then
  rm -f "${WORK_FILE}"
fi
echo "  - Cleanup complete!"

echo ""
echo "=========================================="
echo "Restore Complete!"
echo "=========================================="
`, dbName, host, user)

	return []byte(script)
}

// BackupDockerService returns a backup sidecar service.
func BackupDockerService(primaryService *mapper.DockerService, opts *BackupOptions) *mapper.DockerService {
	if opts == nil {
		opts = DefaultBackupOptions("postgres", "postgres")
	}

	backupName := primaryService.Name + "-backup"

	backupDir := opts.BackupDir
	if backupDir == "" {
		backupDir = "./backups/" + opts.Engine
	}

	retentionDays := opts.RetentionDays
	if retentionDays == 0 {
		retentionDays = 7
	}

	dbName := opts.Name
	if dbName == "" {
		dbName = primaryService.Name
	}

	// Determine image based on engine
	image := "postgres:16-alpine"
	if opts.Engine == "mysql" || opts.Engine == "mariadb" {
		version := opts.Version
		if version == "" {
			version = "8.0"
		}
		image = fmt.Sprintf("mysql:%s", version)
	}

	backup := mapper.NewDockerService(backupName)
	backup.Image = image
	backup.Command = []string{"/scripts/backup.sh"}
	backup.Restart = "no" // Backup runs once per invocation

	// Set environment based on engine
	if opts.Engine == "mysql" || opts.Engine == "mariadb" {
		backup.Environment = map[string]string{
			"BACKUP_DIR":           "/backups",
			"RETENTION_DAYS":       strconv.Itoa(retentionDays),
			"MYSQL_DATABASE":       dbName,
			"MYSQL_HOST":           primaryService.Name,
			"MYSQL_USER":           "root",
			"MYSQL_PASSWORD":       opts.Password,
			"BACKUP_ENCRYPTION_KEY": "",
		}
	} else {
		backup.Environment = map[string]string{
			"BACKUP_DIR":           "/backups",
			"RETENTION_DAYS":       strconv.Itoa(retentionDays),
			"POSTGRES_DB":          dbName,
			"POSTGRES_HOST":        primaryService.Name,
			"POSTGRES_USER":        opts.User,
			"POSTGRES_PASSWORD":    opts.Password,
			"BACKUP_ENCRYPTION_KEY": "",
		}
	}

	// Set volumes
	backup.Volumes = []string{
		fmt.Sprintf("%s:/backups", backupDir),
		fmt.Sprintf("./scripts/%s-backup.sh:/scripts/backup.sh:ro", primaryService.Name),
	}

	// Set dependency on primary
	backup.DependsOn = []string{primaryService.Name}

	// Copy networks from primary
	backup.Networks = append([]string{}, primaryService.Networks...)

	// Set labels
	backup.Labels = map[string]string{
		"homeport.service":  "backup",
		"homeport.database": dbName,
		"homeport.primary":  primaryService.Name,
		"homeport.engine":   opts.Engine,
	}

	return backup
}

// BackupCronDockerService returns a cron-based backup service.
func BackupCronDockerService(primaryService *mapper.DockerService, opts *BackupOptions) *mapper.DockerService {
	if opts == nil {
		opts = DefaultBackupOptions("postgres", "postgres")
	}

	backupName := primaryService.Name + "-backup-cron"

	backupDir := opts.BackupDir
	if backupDir == "" {
		backupDir = "./backups/" + opts.Engine
	}

	retentionDays := opts.RetentionDays
	if retentionDays == 0 {
		retentionDays = 7
	}

	schedule := opts.Schedule
	if schedule == "" {
		schedule = "0 2 * * *" // 2 AM daily
	}

	dbName := opts.Name
	if dbName == "" {
		dbName = primaryService.Name
	}

	backup := mapper.NewDockerService(backupName)
	backup.Restart = "unless-stopped"

	// Use specialized backup images with cron support
	if opts.Engine == "mysql" || opts.Engine == "mariadb" {
		backup.Image = "databack/mysql-backup:latest"
		backup.Environment = map[string]string{
			"DB_SERVER":           primaryService.Name,
			"DB_USER":             "root",
			"DB_PASS":             opts.Password,
			"DB_NAMES":            dbName,
			"DB_DUMP_TARGET":      "/backups",
			"DB_DUMP_FREQ":        "1440", // minutes (24 hours)
			"DB_DUMP_BEGIN":       "0200", // 2 AM
			"DB_DUMP_SAFECHARS":   "true",
			"COMPRESSION":         "gzip",
		}
	} else {
		backup.Image = "prodrigestivill/postgres-backup-local:16-alpine"
		backup.Environment = map[string]string{
			"POSTGRES_HOST":       primaryService.Name,
			"POSTGRES_DB":         dbName,
			"POSTGRES_USER":       opts.User,
			"POSTGRES_PASSWORD":   opts.Password,
			"SCHEDULE":            schedule,
			"BACKUP_KEEP_DAYS":    strconv.Itoa(retentionDays),
			"BACKUP_KEEP_WEEKS":   "4",
			"BACKUP_KEEP_MONTHS":  "6",
			"HEALTHCHECK_PORT":    "8080",
		}
	}

	// Set volumes
	backup.Volumes = []string{
		fmt.Sprintf("%s:/backups", backupDir),
	}

	// Set dependency on primary
	backup.DependsOn = []string{primaryService.Name}

	// Copy networks from primary
	backup.Networks = append([]string{}, primaryService.Networks...)

	// Set labels
	backup.Labels = map[string]string{
		"homeport.service":  "backup-cron",
		"homeport.database": dbName,
		"homeport.primary":  primaryService.Name,
		"homeport.engine":   opts.Engine,
		"homeport.schedule": schedule,
	}

	// Add health check for the cron service
	backup.HealthCheck = &mapper.HealthCheck{
		Test:     []string{"CMD-SHELL", "test -d /backups || exit 1"},
		Interval: 60 * time.Second,
		Timeout:  10 * time.Second,
		Retries:  3,
	}

	return backup
}

// BackupCronScript returns cron-compatible backup script.
func BackupCronScript(opts *BackupOptions) []byte {
	if opts == nil {
		opts = DefaultBackupOptions("postgres", "postgres")
	}

	schedule := opts.Schedule
	if schedule == "" {
		schedule = "0 2 * * *"
	}

	dbName := opts.Name
	if dbName == "" {
		dbName = "database"
	}

	script := fmt.Sprintf(`#!/bin/bash
# Cron Backup Wrapper Script
# Generated by Homeport
# ============================================================================
#
# This script sets up a cron job for automated database backups.
# Add this to your crontab or run it once to configure.
#
# Schedule: %s
# Database: %s
#
# ============================================================================

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BACKUP_SCRIPT="${SCRIPT_DIR}/backup.sh"
CRON_SCHEDULE="%s"
LOG_FILE="${SCRIPT_DIR}/../logs/backup.log"

# Ensure log directory exists
mkdir -p "$(dirname "${LOG_FILE}")"

# Function to add cron job
add_cron_job() {
  # Remove existing job if present
  crontab -l 2>/dev/null | grep -v "${BACKUP_SCRIPT}" > /tmp/current_cron || true

  # Add new job
  echo "${CRON_SCHEDULE} ${BACKUP_SCRIPT} >> ${LOG_FILE} 2>&1" >> /tmp/current_cron

  # Install new crontab
  crontab /tmp/current_cron
  rm /tmp/current_cron

  echo "Cron job installed successfully!"
  echo "Schedule: ${CRON_SCHEDULE}"
  echo "Script: ${BACKUP_SCRIPT}"
  echo "Log: ${LOG_FILE}"
}

# Function to remove cron job
remove_cron_job() {
  crontab -l 2>/dev/null | grep -v "${BACKUP_SCRIPT}" > /tmp/current_cron || true
  crontab /tmp/current_cron
  rm /tmp/current_cron
  echo "Cron job removed."
}

# Function to show status
show_status() {
  echo "Current backup cron jobs:"
  crontab -l 2>/dev/null | grep "${BACKUP_SCRIPT}" || echo "  No backup jobs found."
}

# Main
case "${1:-install}" in
  install)
    add_cron_job
    ;;
  remove)
    remove_cron_job
    ;;
  status)
    show_status
    ;;
  run)
    echo "Running backup now..."
    ${BACKUP_SCRIPT}
    ;;
  *)
    echo "Usage: $0 {install|remove|status|run}"
    exit 1
    ;;
esac
`, schedule, dbName, schedule)

	return []byte(script)
}

// CreateBackupSetup creates a complete backup setup for a database service.
func CreateBackupSetup(primaryService *mapper.DockerService, opts *BackupOptions) (*mapper.DockerService, []byte, []byte, []byte) {
	if opts == nil {
		opts = DefaultBackupOptions(primaryService.Name, "postgres")
	}

	backupService := BackupCronDockerService(primaryService, opts)
	backupScript := DatabaseBackupScript(opts)
	restoreScript := DatabaseRestoreScript(opts)
	cronScript := BackupCronScript(opts)

	return backupService, backupScript, restoreScript, cronScript
}
