// Package database provides shared utilities for database mapping.
package database

import (
	"fmt"
	"strconv"

	"github.com/homeport/homeport/internal/domain/mapper"
)

// ReplicationOptions contains configuration options for database replication.
// This is separate from DatabaseOptions to allow composing configurations.
type ReplicationOptions struct {
	// Name is the database name
	Name string

	// Engine is the database engine (postgres, mysql, mariadb)
	Engine string

	// Version is the database version
	Version string

	// PrimaryHost is the hostname of the primary database
	PrimaryHost string

	// ReplicationUser is the username for replication
	ReplicationUser string

	// ReplicationPassword is the password for replication
	ReplicationPassword string

	// ReplicaCount is the number of replicas to create
	ReplicaCount int

	// SynchronousCommit enables synchronous replication
	SynchronousCommit bool

	// MaxWalSenders is the maximum number of WAL sender processes
	MaxWalSenders int

	// WalKeepSize is the size of WAL to keep for replicas
	WalKeepSize string

	// ReplicationSubnet is the subnet allowed for replication connections
	ReplicationSubnet string
}

// DefaultReplicationOptions returns default options for database replication.
func DefaultReplicationOptions(name, engine string) *ReplicationOptions {
	return &ReplicationOptions{
		Name:                name,
		Engine:              engine,
		Version:             "16",
		PrimaryHost:         name + "-primary",
		ReplicationUser:     "replicator",
		ReplicationPassword: "changeme",
		ReplicaCount:        1,
		SynchronousCommit:   true,
		MaxWalSenders:       10,
		WalKeepSize:         "1GB",
		ReplicationSubnet:   "172.16.0.0/12",
	}
}

// PostgresReplicationConfig returns postgresql.conf for primary with streaming replication.
func PostgresReplicationConfig(opts *ReplicationOptions) []byte {
	if opts == nil {
		opts = DefaultReplicationOptions("postgres", "postgres")
	}

	maxWalSenders := opts.MaxWalSenders
	if maxWalSenders == 0 {
		maxWalSenders = 10
	}

	walKeepSize := opts.WalKeepSize
	if walKeepSize == "" {
		walKeepSize = "1GB"
	}

	syncCommit := "on"
	if !opts.SynchronousCommit {
		syncCommit = "off"
	}

	config := fmt.Sprintf(`# PostgreSQL Primary Replication Configuration
# Generated by Homeport for streaming replication

# ============================================================================
# Connection Settings
# ============================================================================
listen_addresses = '*'
port = 5432
max_connections = 100

# ============================================================================
# Replication Configuration
# ============================================================================
# Enable WAL archiving for replication
wal_level = replica

# Maximum number of concurrent connections from standby servers
max_wal_senders = %d

# Amount of WAL to keep for standby servers
wal_keep_size = %s

# Enable hot standby mode on replicas
hot_standby = on

# Synchronous commit for data durability
synchronous_commit = %s

# Replication slots for reliable replication
max_replication_slots = %d

# ============================================================================
# Write-Ahead Log Settings
# ============================================================================
wal_buffers = 16MB
min_wal_size = 1GB
max_wal_size = 4GB
checkpoint_completion_target = 0.9
checkpoint_timeout = 15min

# ============================================================================
# Archive Settings (optional, for point-in-time recovery)
# ============================================================================
# archive_mode = on
# archive_command = 'cp %%p /var/lib/postgresql/archive/%%f'
# archive_timeout = 60

# ============================================================================
# Logging
# ============================================================================
log_destination = 'stderr'
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%%Y-%%m-%%d_%%H%%M%%S.log'
log_line_prefix = '%%t [%%p]: [%%l-1] user=%%u,db=%%d,app=%%a,client=%%h '
log_replication_commands = on

# ============================================================================
# Memory Settings
# ============================================================================
shared_buffers = 256MB
effective_cache_size = 1GB
maintenance_work_mem = 128MB
work_mem = 16MB
`, maxWalSenders, walKeepSize, syncCommit, maxWalSenders)

	return []byte(config)
}

// PostgresReplicationHBAConfig returns pg_hba.conf allowing replication connections.
func PostgresReplicationHBAConfig(opts *ReplicationOptions) []byte {
	if opts == nil {
		opts = DefaultReplicationOptions("postgres", "postgres")
	}

	replicationUser := opts.ReplicationUser
	if replicationUser == "" {
		replicationUser = "replicator"
	}

	subnet := opts.ReplicationSubnet
	if subnet == "" {
		subnet = "172.16.0.0/12"
	}

	config := fmt.Sprintf(`# PostgreSQL Client Authentication Configuration File
# Generated by Homeport for streaming replication
# ============================================================================

# TYPE  DATABASE        USER            ADDRESS                 METHOD

# Local connections
local   all             all                                     trust
host    all             all             127.0.0.1/32            scram-sha-256
host    all             all             ::1/128                 scram-sha-256

# Docker network connections
host    all             all             172.16.0.0/12           scram-sha-256
host    all             all             10.0.0.0/8              scram-sha-256
host    all             all             192.168.0.0/16          scram-sha-256

# Replication connections
# Allow replication user from Docker networks
host    replication     %s              %s                      scram-sha-256
host    replication     %s              10.0.0.0/8              scram-sha-256
host    replication     %s              192.168.0.0/16          scram-sha-256

# Allow replication from any host (use with caution in production)
# host    replication     %s              0.0.0.0/0               scram-sha-256
`, replicationUser, subnet, replicationUser, replicationUser, replicationUser)

	return []byte(config)
}

// PostgresReplicaSetupScript returns full automation script to setup replica.
func PostgresReplicaSetupScript(opts *ReplicationOptions) []byte {
	if opts == nil {
		opts = DefaultReplicationOptions("postgres", "postgres")
	}

	primaryHost := opts.PrimaryHost
	if primaryHost == "" {
		primaryHost = "postgres-primary"
	}

	replicationUser := opts.ReplicationUser
	if replicationUser == "" {
		replicationUser = "replicator"
	}

	script := fmt.Sprintf(`#!/bin/bash
# Full PostgreSQL Replica Setup Script
# Generated by Homeport for streaming replication
# ============================================================================
set -e

# ============================================================================
# Configuration
# ============================================================================
PRIMARY_HOST=${PRIMARY_HOST:-%s}
REPLICATION_USER=${REPLICATION_USER:-%s}
REPLICATION_PASSWORD=${REPLICATION_PASSWORD:-changeme}
DATA_DIR=${PGDATA:-/var/lib/postgresql/data}
REPLICA_SLOT=${REPLICA_SLOT:-replica_slot_1}

echo "=========================================="
echo "PostgreSQL Replica Setup"
echo "=========================================="
echo "Primary Host: ${PRIMARY_HOST}"
echo "Replication User: ${REPLICATION_USER}"
echo "Data Directory: ${DATA_DIR}"
echo ""

# ============================================================================
# Wait for primary to be ready
# ============================================================================
echo "[1/6] Waiting for primary database to be ready..."
until pg_isready -h ${PRIMARY_HOST} -U postgres -q; do
  echo "  - Primary not ready, retrying in 2 seconds..."
  sleep 2
done
echo "  - Primary is ready!"

# ============================================================================
# Create replication user on primary if not exists
# ============================================================================
echo "[2/6] Ensuring replication user exists on primary..."
PGPASSWORD=${REPLICATION_PASSWORD} psql -h ${PRIMARY_HOST} -U postgres -tc \
  "SELECT 1 FROM pg_roles WHERE rolname='${REPLICATION_USER}'" | grep -q 1 || \
PGPASSWORD=${REPLICATION_PASSWORD} psql -h ${PRIMARY_HOST} -U postgres -c \
  "CREATE USER ${REPLICATION_USER} WITH REPLICATION ENCRYPTED PASSWORD '${REPLICATION_PASSWORD}';"
echo "  - Replication user ready!"

# ============================================================================
# Create replication slot on primary if not exists
# ============================================================================
echo "[3/6] Creating replication slot on primary..."
PGPASSWORD=${REPLICATION_PASSWORD} psql -h ${PRIMARY_HOST} -U postgres -tc \
  "SELECT 1 FROM pg_replication_slots WHERE slot_name='${REPLICA_SLOT}'" | grep -q 1 || \
PGPASSWORD=${REPLICATION_PASSWORD} psql -h ${PRIMARY_HOST} -U postgres -c \
  "SELECT pg_create_physical_replication_slot('${REPLICA_SLOT}');"
echo "  - Replication slot ready!"

# ============================================================================
# Stop PostgreSQL if running
# ============================================================================
echo "[4/6] Stopping local PostgreSQL if running..."
pg_ctl stop -D ${DATA_DIR} -m fast 2>/dev/null || true
sleep 2
echo "  - PostgreSQL stopped!"

# ============================================================================
# Clear data directory and perform base backup
# ============================================================================
echo "[5/6] Performing base backup from primary..."
rm -rf ${DATA_DIR}/*

PGPASSWORD=${REPLICATION_PASSWORD} pg_basebackup \
  -h ${PRIMARY_HOST} \
  -U ${REPLICATION_USER} \
  -D ${DATA_DIR} \
  -Fp -Xs -P -R \
  -S ${REPLICA_SLOT}

# Ensure proper permissions
chmod 700 ${DATA_DIR}
echo "  - Base backup complete!"

# ============================================================================
# Configure standby settings
# ============================================================================
echo "[6/6] Configuring standby settings..."

# The -R flag in pg_basebackup creates standby.signal and postgresql.auto.conf
# Add additional settings if needed
cat >> ${DATA_DIR}/postgresql.auto.conf << EOF

# Homeport Replica Configuration
hot_standby = on
hot_standby_feedback = on
max_standby_streaming_delay = 30s
max_standby_archive_delay = 30s
EOF

echo "  - Standby configuration complete!"

# ============================================================================
# Start as standby
# ============================================================================
echo ""
echo "=========================================="
echo "Replica setup complete!"
echo "=========================================="
echo ""
echo "Starting PostgreSQL as standby..."
pg_ctl start -D ${DATA_DIR} -l ${DATA_DIR}/logfile

echo ""
echo "Replica is now running and streaming from primary."
echo "To verify replication status on primary, run:"
echo "  SELECT * FROM pg_stat_replication;"
echo ""
echo "To verify replica status, run:"
echo "  SELECT * FROM pg_stat_wal_receiver;"
`, primaryHost, replicationUser)

	return []byte(script)
}

// ReplicaDockerService returns a Docker service definition for replica.
func ReplicaDockerService(primary *mapper.DockerService, opts *ReplicationOptions) *mapper.DockerService {
	if opts == nil {
		opts = DefaultReplicationOptions("postgres", "postgres")
	}

	replicaName := primary.Name + "-replica"
	if opts.ReplicaCount > 1 {
		replicaName = primary.Name + "-replica-1"
	}

	primaryHost := opts.PrimaryHost
	if primaryHost == "" {
		primaryHost = primary.Name
	}

	replicationUser := opts.ReplicationUser
	if replicationUser == "" {
		replicationUser = "replicator"
	}

	replica := mapper.NewDockerService(replicaName)

	// Clone primary configuration
	replica.Image = primary.Image
	replica.Restart = primary.Restart
	replica.Networks = append([]string{}, primary.Networks...)

	// Set replica-specific environment
	replica.Environment = map[string]string{
		"PRIMARY_HOST":           primaryHost,
		"REPLICATION_USER":       replicationUser,
		"REPLICATION_PASSWORD":   opts.ReplicationPassword,
		"POSTGRES_PASSWORD":      opts.ReplicationPassword,
		"PGDATA":                 "/var/lib/postgresql/data",
		"REPLICA_SLOT":           "replica_slot_1",
	}

	// Copy relevant environment from primary
	if dbName, ok := primary.Environment["POSTGRES_DB"]; ok {
		replica.Environment["POSTGRES_DB"] = dbName
	}

	// Set replica volumes (separate data directory)
	replica.Volumes = []string{
		fmt.Sprintf("./data/%s:/var/lib/postgresql/data", replicaName),
		fmt.Sprintf("./scripts/%s-setup.sh:/docker-entrypoint-initdb.d/replica-setup.sh:ro", replicaName),
	}

	// Replica should not expose the same port as primary
	// Use a different host port or no port exposure
	replica.Ports = []string{"5433:5432"}

	// Set dependency on primary
	replica.DependsOn = []string{primary.Name}

	// Set labels
	replica.Labels = map[string]string{
		"homeport.service":  "database-replica",
		"homeport.database": opts.Name,
		"homeport.primary":  primary.Name,
		"homeport.role":     "replica",
		"homeport.engine":   opts.Engine,
	}

	// Copy health check from primary if exists
	if primary.HealthCheck != nil {
		replica.HealthCheck = &mapper.HealthCheck{
			Test:        primary.HealthCheck.Test,
			Interval:    primary.HealthCheck.Interval,
			Timeout:     primary.HealthCheck.Timeout,
			Retries:     primary.HealthCheck.Retries,
			StartPeriod: primary.HealthCheck.StartPeriod,
		}
	}

	return replica
}

// MySQLReplicationConfig returns my.cnf for primary with binlog replication.
func MySQLReplicationConfig(opts *ReplicationOptions) []byte {
	if opts == nil {
		opts = DefaultReplicationOptions("mysql", "mysql")
	}

	serverID := 1 // Primary always uses server-id 1

	config := fmt.Sprintf(`# MySQL Primary Replication Configuration
# Generated by Homeport for binary log replication
# ============================================================================

[mysqld]
# ============================================================================
# Server Identification
# ============================================================================
server-id = %d

# ============================================================================
# Binary Logging Configuration
# ============================================================================
# Enable binary logging for replication
log_bin = mysql-bin
binlog_format = ROW
binlog_row_image = FULL

# Expire binary logs after 7 days
binlog_expire_logs_seconds = 604800

# Maximum size per binary log file
max_binlog_size = 100M

# Sync binary log to disk on each write for durability
sync_binlog = 1

# ============================================================================
# GTID Configuration (Recommended for MySQL 5.6+)
# ============================================================================
gtid_mode = ON
enforce_gtid_consistency = ON
log_slave_updates = ON

# ============================================================================
# InnoDB Settings for Replication
# ============================================================================
innodb_flush_log_at_trx_commit = 1
innodb_buffer_pool_size = 256M
innodb_log_file_size = 512M
innodb_flush_method = O_DIRECT

# ============================================================================
# Connection Settings
# ============================================================================
max_connections = 151
bind-address = 0.0.0.0

# ============================================================================
# Character Set
# ============================================================================
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci

# ============================================================================
# Logging
# ============================================================================
log_error = /var/log/mysql/error.log
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow-query.log
long_query_time = 2

# ============================================================================
# SQL Mode
# ============================================================================
sql_mode = STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION

[mysql]
default-character-set = utf8mb4

[client]
default-character-set = utf8mb4
`, serverID)

	return []byte(config)
}

// MySQLReplicaSetupScript returns full automation script to setup replica.
func MySQLReplicaSetupScript(opts *ReplicationOptions) []byte {
	if opts == nil {
		opts = DefaultReplicationOptions("mysql", "mysql")
	}

	primaryHost := opts.PrimaryHost
	if primaryHost == "" {
		primaryHost = "mysql-primary"
	}

	replicationUser := opts.ReplicationUser
	if replicationUser == "" {
		replicationUser = "replicator"
	}

	script := fmt.Sprintf(`#!/bin/bash
# Full MySQL Replica Setup Script
# Generated by Homeport for binary log replication with GTID
# ============================================================================
set -e

# ============================================================================
# Configuration
# ============================================================================
PRIMARY_HOST=${PRIMARY_HOST:-%s}
REPLICATION_USER=${REPLICATION_USER:-%s}
REPLICATION_PASSWORD=${REPLICATION_PASSWORD:-changeme}
ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD:-changeme}
REPLICA_SERVER_ID=${REPLICA_SERVER_ID:-2}

echo "=========================================="
echo "MySQL Replica Setup"
echo "=========================================="
echo "Primary Host: ${PRIMARY_HOST}"
echo "Replication User: ${REPLICATION_USER}"
echo "Replica Server ID: ${REPLICA_SERVER_ID}"
echo ""

# ============================================================================
# Wait for primary to be ready
# ============================================================================
echo "[1/5] Waiting for primary database to be ready..."
until mysqladmin -h ${PRIMARY_HOST} -u root -p${ROOT_PASSWORD} ping --silent; do
  echo "  - Primary not ready, retrying in 2 seconds..."
  sleep 2
done
echo "  - Primary is ready!"

# ============================================================================
# Create replication user on primary if not exists
# ============================================================================
echo "[2/5] Ensuring replication user exists on primary..."
mysql -h ${PRIMARY_HOST} -u root -p${ROOT_PASSWORD} -e "
  CREATE USER IF NOT EXISTS '${REPLICATION_USER}'@'%%' IDENTIFIED BY '${REPLICATION_PASSWORD}';
  GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO '${REPLICATION_USER}'@'%%';
  FLUSH PRIVILEGES;
"
echo "  - Replication user ready!"

# ============================================================================
# Wait for local MySQL to be ready
# ============================================================================
echo "[3/5] Waiting for local MySQL to be ready..."
until mysqladmin -u root -p${ROOT_PASSWORD} ping --silent; do
  echo "  - Local MySQL not ready, retrying in 2 seconds..."
  sleep 2
done
echo "  - Local MySQL is ready!"

# ============================================================================
# Configure replica settings
# ============================================================================
echo "[4/5] Configuring replica settings..."

# Set server ID dynamically if not in config
mysql -u root -p${ROOT_PASSWORD} -e "SET GLOBAL server_id = ${REPLICA_SERVER_ID};"

# Stop any existing replication
mysql -u root -p${ROOT_PASSWORD} -e "STOP REPLICA;" 2>/dev/null || true
mysql -u root -p${ROOT_PASSWORD} -e "STOP SLAVE;" 2>/dev/null || true

# Reset replica state
mysql -u root -p${ROOT_PASSWORD} -e "RESET REPLICA ALL;" 2>/dev/null || \
mysql -u root -p${ROOT_PASSWORD} -e "RESET SLAVE ALL;" 2>/dev/null || true

echo "  - Replica settings configured!"

# ============================================================================
# Configure replication source and start
# ============================================================================
echo "[5/5] Starting replication..."

# Configure replication using GTID (MySQL 5.6+)
mysql -u root -p${ROOT_PASSWORD} -e "
  CHANGE REPLICATION SOURCE TO
    SOURCE_HOST='${PRIMARY_HOST}',
    SOURCE_USER='${REPLICATION_USER}',
    SOURCE_PASSWORD='${REPLICATION_PASSWORD}',
    SOURCE_AUTO_POSITION=1,
    GET_SOURCE_PUBLIC_KEY=1;
" 2>/dev/null || \
mysql -u root -p${ROOT_PASSWORD} -e "
  CHANGE MASTER TO
    MASTER_HOST='${PRIMARY_HOST}',
    MASTER_USER='${REPLICATION_USER}',
    MASTER_PASSWORD='${REPLICATION_PASSWORD}',
    MASTER_AUTO_POSITION=1,
    GET_MASTER_PUBLIC_KEY=1;
"

# Start replica
mysql -u root -p${ROOT_PASSWORD} -e "START REPLICA;" 2>/dev/null || \
mysql -u root -p${ROOT_PASSWORD} -e "START SLAVE;"

echo "  - Replication started!"

# ============================================================================
# Show replication status
# ============================================================================
echo ""
echo "=========================================="
echo "Replica setup complete!"
echo "=========================================="
echo ""
echo "Replication Status:"
mysql -u root -p${ROOT_PASSWORD} -e "SHOW REPLICA STATUS\G" 2>/dev/null || \
mysql -u root -p${ROOT_PASSWORD} -e "SHOW SLAVE STATUS\G"

echo ""
echo "To monitor replication on primary, run:"
echo "  SHOW PROCESSLIST;"
echo "  SHOW BINARY LOGS;"
echo ""
echo "To check replica lag:"
echo "  SHOW REPLICA STATUS\\G"
`, primaryHost, replicationUser)

	return []byte(script)
}

// MySQLReplicaDockerService returns a Docker service definition for MySQL replica.
func MySQLReplicaDockerService(primary *mapper.DockerService, opts *ReplicationOptions) *mapper.DockerService {
	if opts == nil {
		opts = DefaultReplicationOptions("mysql", "mysql")
	}

	replicaName := primary.Name + "-replica"
	replicaIndex := 1
	if opts.ReplicaCount > 1 {
		replicaName = primary.Name + "-replica-" + strconv.Itoa(replicaIndex)
	}

	primaryHost := opts.PrimaryHost
	if primaryHost == "" {
		primaryHost = primary.Name
	}

	replicationUser := opts.ReplicationUser
	if replicationUser == "" {
		replicationUser = "replicator"
	}

	replica := mapper.NewDockerService(replicaName)

	// Clone primary configuration
	replica.Image = primary.Image
	replica.Restart = primary.Restart
	replica.Networks = append([]string{}, primary.Networks...)

	// Set replica-specific environment
	replica.Environment = map[string]string{
		"PRIMARY_HOST":           primaryHost,
		"REPLICATION_USER":       replicationUser,
		"REPLICATION_PASSWORD":   opts.ReplicationPassword,
		"MYSQL_ROOT_PASSWORD":    opts.ReplicationPassword,
		"REPLICA_SERVER_ID":      strconv.Itoa(replicaIndex + 1),
	}

	// Copy relevant environment from primary
	if dbName, ok := primary.Environment["MYSQL_DATABASE"]; ok {
		replica.Environment["MYSQL_DATABASE"] = dbName
	}

	// Set replica volumes (separate data directory)
	replica.Volumes = []string{
		fmt.Sprintf("./data/%s:/var/lib/mysql", replicaName),
		fmt.Sprintf("./config/%s/my.cnf:/etc/mysql/conf.d/replica.cnf:ro", replicaName),
		fmt.Sprintf("./scripts/%s-setup.sh:/docker-entrypoint-initdb.d/replica-setup.sh:ro", replicaName),
	}

	// Replica should not expose the same port as primary
	replica.Ports = []string{"3307:3306"}

	// Set dependency on primary
	replica.DependsOn = []string{primary.Name}

	// Set labels
	replica.Labels = map[string]string{
		"homeport.service":  "database-replica",
		"homeport.database": opts.Name,
		"homeport.primary":  primary.Name,
		"homeport.role":     "replica",
		"homeport.engine":   opts.Engine,
	}

	// Copy health check from primary if exists
	if primary.HealthCheck != nil {
		replica.HealthCheck = &mapper.HealthCheck{
			Test:        primary.HealthCheck.Test,
			Interval:    primary.HealthCheck.Interval,
			Timeout:     primary.HealthCheck.Timeout,
			Retries:     primary.HealthCheck.Retries,
			StartPeriod: primary.HealthCheck.StartPeriod,
		}
	}

	return replica
}

// CreateReplicationSetup creates a complete replication setup with primary modifications.
func CreateReplicationSetup(primary *mapper.DockerService, opts *ReplicationOptions) (*mapper.DockerService, []byte, []byte, []byte) {
	if opts == nil {
		opts = DefaultReplicationOptions(primary.Name, "postgres")
	}

	var replica *mapper.DockerService
	var config, hbaConfig, script []byte

	switch opts.Engine {
	case "mysql", "mariadb":
		replica = MySQLReplicaDockerService(primary, opts)
		config = MySQLReplicationConfig(opts)
		script = MySQLReplicaSetupScript(opts)
		hbaConfig = nil
	default: // postgres
		replica = ReplicaDockerService(primary, opts)
		config = PostgresReplicationConfig(opts)
		hbaConfig = PostgresReplicationHBAConfig(opts)
		script = PostgresReplicaSetupScript(opts)
	}

	return replica, config, hbaConfig, script
}
