// Package shared provides shared utilities for storage mappers.
package shared

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/homeport/homeport/internal/domain/mapper"
)

// XFSQuotaSetupScript generates a script to set up XFS project quotas.
func XFSQuotaSetupScript(opts *mapper.VolumeOptions) ([]byte, error) {
	if opts.Quota == nil || !opts.Quota.UseXFSQuota {
		return nil, fmt.Errorf("XFS quota not enabled")
	}

	tmpl := `#!/bin/bash
# XFS Project Quota Setup Script
# Volume: {{.Name}}
# Size Limit: {{.Quota.SizeGB}}GB
# Project ID: {{.Quota.ProjectID}}
# Generated by Homeport
#
# This script enforces size limits using XFS project quotas,
# mirroring cloud provider volume size constraints.

set -e

# Configuration
VOLUME_NAME="{{.Name}}"
{{if .Quota.UseLoopDevice}}
MOUNT_POINT="/var/lib/homeport/mounts/{{.Name}}"
{{else}}
MOUNT_POINT="${MOUNT_POINT:-/var/lib/docker/volumes/{{.Name}}/_data}"
{{end}}
PROJECT_ID="{{.Quota.ProjectID}}"
SIZE_LIMIT="{{.Quota.SizeGB}}g"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  XFS Project Quota Setup"
echo "========================================="
echo ""
echo "Volume: $VOLUME_NAME"
echo "Mount Point: $MOUNT_POINT"
echo "Size Limit: $SIZE_LIMIT"
echo "Project ID: $PROJECT_ID"
echo ""

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_error "This script must be run as root"
    exit 1
fi

# Check for xfs_quota
if ! command -v xfs_quota >/dev/null 2>&1; then
    log_error "xfs_quota is required but not installed"
    echo "Install with: apt-get install xfsprogs"
    exit 1
fi

# Verify mount point exists
if [ ! -d "$MOUNT_POINT" ]; then
    log_error "Mount point does not exist: $MOUNT_POINT"
    exit 1
fi

# Verify XFS filesystem
FS_TYPE=$(df -T "$MOUNT_POINT" 2>/dev/null | tail -1 | awk '{print $2}')
if [ "$FS_TYPE" != "xfs" ]; then
    log_error "Mount point is not XFS filesystem (found: $FS_TYPE)"
    echo ""
    echo "XFS is required for project quotas."
    echo "Options:"
    echo "  1. Use an XFS-formatted disk for Docker storage"
    echo "  2. Create a loop device with XFS (use setup_encryption.sh)"
    echo "  3. Reformat the storage as XFS (WARNING: destroys data)"
    exit 1
fi

# Check if prjquota is enabled
MOUNT_OPTS=$(grep " $MOUNT_POINT " /proc/mounts 2>/dev/null | awk '{print $4}')
if [ -z "$MOUNT_OPTS" ]; then
    # Try to find parent mount
    PARENT_MOUNT=$(df "$MOUNT_POINT" | tail -1 | awk '{print $6}')
    MOUNT_OPTS=$(grep " $PARENT_MOUNT " /proc/mounts | awk '{print $4}')
fi

if [[ "$MOUNT_OPTS" != *"prjquota"* ]] && [[ "$MOUNT_OPTS" != *"pquota"* ]]; then
    log_warn "prjquota not enabled on mount"
    log_info "Attempting to remount with prjquota..."

    # Get the device
    DEVICE=$(df "$MOUNT_POINT" | tail -1 | awk '{print $1}')
    PARENT_MOUNT=$(df "$MOUNT_POINT" | tail -1 | awk '{print $6}')

    if mount -o remount,prjquota "$PARENT_MOUNT" 2>/dev/null; then
        log_info "Successfully remounted with prjquota"
    else
        log_error "Failed to enable prjquota"
        echo ""
        echo "To enable prjquota permanently, add 'prjquota' to /etc/fstab:"
        echo "  $DEVICE $PARENT_MOUNT xfs defaults,prjquota 0 0"
        echo ""
        echo "Then remount: mount -o remount $PARENT_MOUNT"
        exit 1
    fi
fi

# Create project quota files if they don't exist
PROJECTS_FILE="/etc/projects"
PROJID_FILE="/etc/projid"

# Add project entry if not exists
if ! grep -q "^${PROJECT_ID}:" "$PROJECTS_FILE" 2>/dev/null; then
    log_info "Adding project to $PROJECTS_FILE"
    echo "${PROJECT_ID}:${MOUNT_POINT}" >> "$PROJECTS_FILE"
else
    log_info "Project already in $PROJECTS_FILE"
fi

# Add projid entry if not exists
if ! grep -q "^${VOLUME_NAME}:${PROJECT_ID}" "$PROJID_FILE" 2>/dev/null; then
    log_info "Adding project ID to $PROJID_FILE"
    echo "${VOLUME_NAME}:${PROJECT_ID}" >> "$PROJID_FILE"
else
    log_info "Project ID already in $PROJID_FILE"
fi

# Set up project on directory
log_info "Initializing project quota on directory..."
xfs_quota -x -c "project -s ${VOLUME_NAME}" "$MOUNT_POINT" 2>/dev/null || \
    xfs_quota -x -c "project -s -p ${MOUNT_POINT} ${PROJECT_ID}" "$(df "$MOUNT_POINT" | tail -1 | awk '{print $6}')"

# Set quota limit
log_info "Setting quota limit: $SIZE_LIMIT"
xfs_quota -x -c "limit -p bhard=${SIZE_LIMIT} ${VOLUME_NAME}" "$(df "$MOUNT_POINT" | tail -1 | awk '{print $6}')" 2>/dev/null || \
    xfs_quota -x -c "limit -p bhard=${SIZE_LIMIT} ${PROJECT_ID}" "$(df "$MOUNT_POINT" | tail -1 | awk '{print $6}')"

echo ""
echo "========================================="
echo "  Quota Configuration Complete"
echo "========================================="
echo ""

# Show current quota status
log_info "Current quota status:"
xfs_quota -x -c "report -pbih" "$(df "$MOUNT_POINT" | tail -1 | awk '{print $6}')" 2>/dev/null | head -20

echo ""
log_info "Project quota of $SIZE_LIMIT configured for $VOLUME_NAME"
echo ""
echo "To check quota usage:"
echo "  xfs_quota -x -c 'report -pbih' $(df "$MOUNT_POINT" | tail -1 | awk '{print $6}')"
`

	t, err := template.New("xfs-quota").Parse(tmpl)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, opts); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.Bytes(), nil
}

// LoopDeviceSetupScript generates a script to create a size-limited loop device.
// This is used when XFS quotas aren't available or when a hard size limit is needed.
func LoopDeviceSetupScript(opts *mapper.VolumeOptions) ([]byte, error) {
	if opts.Quota == nil {
		return nil, fmt.Errorf("quota options not set")
	}

	tmpl := `#!/bin/bash
# Loop Device Setup Script
# Volume: {{.Name}}
# Size: {{.Quota.SizeGB}}GB
# Generated by Homeport
#
# Creates a fixed-size loop device to enforce volume size limits.
# This provides a hard size limit similar to cloud provider volumes.

set -e

# Configuration
VOLUME_NAME="{{.Name}}"
VOLUME_SIZE="{{.Quota.SizeGB}}G"
LOOP_FILE="/var/lib/homeport/volumes/${VOLUME_NAME}.img"
MOUNT_POINT="/var/lib/homeport/mounts/${VOLUME_NAME}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  Loop Device Volume Setup"
echo "========================================="
echo ""
echo "Volume: $VOLUME_NAME"
echo "Size: $VOLUME_SIZE"
echo ""

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_error "This script must be run as root"
    exit 1
fi

# Create directories
mkdir -p /var/lib/homeport/{volumes,mounts}

# Create loop file if it doesn't exist
if [ ! -f "$LOOP_FILE" ]; then
    log_info "Creating volume file: $LOOP_FILE ($VOLUME_SIZE)"
    truncate -s "$VOLUME_SIZE" "$LOOP_FILE"
else
    CURRENT_SIZE=$(stat -c%s "$LOOP_FILE" 2>/dev/null || stat -f%z "$LOOP_FILE")
    log_info "Volume file exists: $LOOP_FILE ($(numfmt --to=iec $CURRENT_SIZE))"
fi

# Set up loop device
EXISTING_LOOP=$(losetup -j "$LOOP_FILE" 2>/dev/null | cut -d: -f1 | head -1)

if [ -n "$EXISTING_LOOP" ]; then
    LOOP_DEV="$EXISTING_LOOP"
    log_info "Using existing loop device: $LOOP_DEV"
else
    LOOP_DEV=$(losetup -f)
    log_info "Setting up loop device: $LOOP_DEV"
    losetup "$LOOP_DEV" "$LOOP_FILE"
fi

# Create filesystem if needed
if ! blkid "$LOOP_DEV" >/dev/null 2>&1; then
    log_info "Creating XFS filesystem..."
    mkfs.xfs -f "$LOOP_DEV"
fi

# Mount volume
mkdir -p "$MOUNT_POINT"
if ! mountpoint -q "$MOUNT_POINT"; then
    log_info "Mounting volume at $MOUNT_POINT..."
    mount -o prjquota "$LOOP_DEV" "$MOUNT_POINT"
else
    log_info "Volume already mounted at $MOUNT_POINT"
fi

echo ""
echo "========================================="
echo "  Setup Complete"
echo "========================================="
echo ""
echo "Volume mounted at: $MOUNT_POINT"
echo "Size limit: $VOLUME_SIZE (enforced by file size)"
echo ""
echo "To use with Docker:"
echo "  docker volume create --driver local \\"
echo "    --opt type=none \\"
echo "    --opt o=bind \\"
echo "    --opt device=$MOUNT_POINT \\"
echo "    $VOLUME_NAME"
echo ""
echo "Or in docker-compose.yml:"
echo "  services:"
echo "    myapp:"
echo "      volumes:"
echo "        - $MOUNT_POINT:/data"
`

	t, err := template.New("loop-device").Parse(tmpl)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, opts); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.Bytes(), nil
}

// QuotaCheckScript generates a script to check quota usage.
func QuotaCheckScript(volumeName string, projectID int) []byte {
	return []byte(fmt.Sprintf(`#!/bin/bash
# Quota Check Script
# Volume: %s
# Project ID: %d
# Generated by Homeport

VOLUME_NAME="%s"
MOUNT_POINT="${MOUNT_POINT:-/var/lib/homeport/mounts/%s}"

if [ ! -d "$MOUNT_POINT" ]; then
    MOUNT_POINT="/var/lib/docker/volumes/%s/_data"
fi

echo "Quota status for: $VOLUME_NAME"
echo ""

if command -v xfs_quota >/dev/null 2>&1; then
    PARENT_MOUNT=$(df "$MOUNT_POINT" 2>/dev/null | tail -1 | awk '{print $6}')
    if [ -n "$PARENT_MOUNT" ]; then
        xfs_quota -x -c "report -pbih" "$PARENT_MOUNT" 2>/dev/null | grep -E "(Project|%s|%d)"
    fi
else
    echo "xfs_quota not installed. Install with: apt-get install xfsprogs"
fi

echo ""
echo "Disk usage:"
du -sh "$MOUNT_POINT" 2>/dev/null || echo "Mount point not accessible"
`, volumeName, projectID, volumeName, volumeName, volumeName, volumeName, projectID))
}
