// Package shared provides shared utilities for storage mappers.
package shared

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/homeport/homeport/internal/domain/mapper"
)

// LUKSSetupScript generates a LUKS encryption setup script.
func LUKSSetupScript(opts *mapper.VolumeOptions) ([]byte, error) {
	if opts.Encryption == nil || !opts.Encryption.Enabled {
		return nil, fmt.Errorf("encryption not enabled")
	}

	tmpl := `#!/bin/bash
# LUKS Encryption Setup Script
# Volume: {{.Name}}
# Size: {{.SizeGB}}GB
# Generated by Homeport
#
# This script creates an encrypted volume using LUKS2.
# It mirrors cloud provider encryption ({{.CloudProvider}} {{if .Encryption.CloudKeyType}}{{.Encryption.CloudKeyType}}{{end}})

set -e

# Configuration
VOLUME_NAME="{{.Name}}"
VOLUME_SIZE="{{.SizeGB}}G"
LOOP_FILE="/var/lib/homeport/volumes/${VOLUME_NAME}.img"
LUKS_NAME="luks-${VOLUME_NAME}"
MOUNT_POINT="/var/lib/homeport/mounts/${VOLUME_NAME}"
KEY_FILE="/var/lib/homeport/keys/${VOLUME_NAME}.key"
CIPHER="{{.Encryption.Algorithm}}"
KEY_SIZE="{{.Encryption.KeySize}}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  LUKS Encrypted Volume Setup"
echo "========================================="
echo ""
echo "Volume: $VOLUME_NAME"
echo "Size: $VOLUME_SIZE"
echo "Cipher: $CIPHER"
echo "Key Size: $KEY_SIZE bits"
echo ""

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_error "This script must be run as root"
    exit 1
fi

# Check prerequisites
for cmd in cryptsetup losetup mkfs.xfs; do
    if ! command -v $cmd >/dev/null 2>&1; then
        log_error "$cmd is required but not installed"
        echo "Install with: apt-get install cryptsetup xfsprogs"
        exit 1
    fi
done

# Create directories
log_info "Creating directories..."
mkdir -p /var/lib/homeport/{volumes,mounts,keys}
chmod 700 /var/lib/homeport/keys

# Create loop file if it doesn't exist
if [ ! -f "$LOOP_FILE" ]; then
    log_info "Creating volume file: $LOOP_FILE ($VOLUME_SIZE)"
    truncate -s "$VOLUME_SIZE" "$LOOP_FILE"
else
    log_info "Volume file already exists: $LOOP_FILE"
fi

# Set up loop device
LOOP_DEV=""
EXISTING_LOOP=$(losetup -j "$LOOP_FILE" 2>/dev/null | cut -d: -f1 | head -1)

if [ -n "$EXISTING_LOOP" ]; then
    LOOP_DEV="$EXISTING_LOOP"
    log_info "Using existing loop device: $LOOP_DEV"
else
    LOOP_DEV=$(losetup -f)
    log_info "Setting up loop device: $LOOP_DEV"
    losetup "$LOOP_DEV" "$LOOP_FILE"
fi

{{if eq .Encryption.KeySource "generated"}}
# Generate key file if it doesn't exist
if [ ! -f "$KEY_FILE" ]; then
    log_info "Generating encryption key..."
    dd if=/dev/urandom of="$KEY_FILE" bs=4096 count=1 2>/dev/null
    chmod 400 "$KEY_FILE"
    log_warn "Key file created: $KEY_FILE"
    log_warn "BACKUP THIS FILE! Without it, data cannot be recovered."
else
    log_info "Using existing key file: $KEY_FILE"
fi
{{else if eq .Encryption.KeySource "file"}}
# Use provided key file
KEY_FILE="{{.Encryption.KeyFile}}"
if [ ! -f "$KEY_FILE" ]; then
    log_error "Key file not found: $KEY_FILE"
    exit 1
fi
log_info "Using key file: $KEY_FILE"
{{end}}

# Check if already LUKS formatted
if ! cryptsetup isLuks "$LOOP_DEV" 2>/dev/null; then
    log_info "Formatting volume with LUKS2..."
    cryptsetup luksFormat \
        --type luks2 \
        --cipher "$CIPHER" \
        --key-size "$KEY_SIZE" \
        --hash sha256 \
        --pbkdf argon2id \
        --batch-mode \
        --key-file "$KEY_FILE" \
        "$LOOP_DEV"
    log_info "LUKS format complete"
else
    log_info "Volume already LUKS formatted"
fi

# Open LUKS volume
if [ ! -e "/dev/mapper/$LUKS_NAME" ]; then
    log_info "Opening LUKS volume..."
    cryptsetup luksOpen \
        --key-file "$KEY_FILE" \
        "$LOOP_DEV" \
        "$LUKS_NAME"
else
    log_info "LUKS volume already open"
fi

# Create filesystem if needed
if ! blkid "/dev/mapper/$LUKS_NAME" >/dev/null 2>&1; then
    log_info "Creating XFS filesystem..."
    mkfs.xfs -f "/dev/mapper/$LUKS_NAME"
else
    log_info "Filesystem already exists"
fi

# Mount volume
mkdir -p "$MOUNT_POINT"
if ! mountpoint -q "$MOUNT_POINT"; then
    log_info "Mounting volume at $MOUNT_POINT..."
    mount "/dev/mapper/$LUKS_NAME" "$MOUNT_POINT"
else
    log_info "Volume already mounted at $MOUNT_POINT"
fi

echo ""
echo "========================================="
echo "  Setup Complete"
echo "========================================="
echo ""
echo "Volume mounted at: $MOUNT_POINT"
echo "Key file: $KEY_FILE"
echo ""
echo "To use with Docker Compose:"
echo "  services:"
echo "    myapp:"
echo "      volumes:"
echo "        - $MOUNT_POINT:/data"
echo ""
echo "To create a Docker named volume pointing to this location:"
echo "  docker volume create --driver local \\"
echo "    --opt type=none \\"
echo "    --opt o=bind \\"
echo "    --opt device=$MOUNT_POINT \\"
echo "    $VOLUME_NAME"
echo ""
log_warn "IMPORTANT: Backup your key file securely!"
log_warn "Without it, encrypted data cannot be recovered."
{{if .Encryption.CloudKeyID}}
echo ""
log_info "Original cloud encryption key: {{.Encryption.CloudKeyID}}"
{{end}}
`

	t, err := template.New("luks-setup").Parse(tmpl)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, opts); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.Bytes(), nil
}

// LUKSTeardownScript generates a script to safely unmount and close LUKS volume.
func LUKSTeardownScript(volumeName string) []byte {
	return []byte(fmt.Sprintf(`#!/bin/bash
# LUKS Volume Teardown Script
# Volume: %s
# Generated by Homeport

set -e

VOLUME_NAME="%s"
LUKS_NAME="luks-${VOLUME_NAME}"
MOUNT_POINT="/var/lib/homeport/mounts/${VOLUME_NAME}"
LOOP_FILE="/var/lib/homeport/volumes/${VOLUME_NAME}.img"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  LUKS Volume Teardown"
echo "========================================="
echo ""

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_error "This script must be run as root"
    exit 1
fi

# Unmount if mounted
if mountpoint -q "$MOUNT_POINT" 2>/dev/null; then
    log_info "Unmounting $MOUNT_POINT..."
    umount "$MOUNT_POINT"
fi

# Close LUKS volume if open
if [ -e "/dev/mapper/$LUKS_NAME" ]; then
    log_info "Closing LUKS volume..."
    cryptsetup luksClose "$LUKS_NAME"
fi

# Detach loop device
LOOP_DEV=$(losetup -j "$LOOP_FILE" 2>/dev/null | cut -d: -f1 | head -1)
if [ -n "$LOOP_DEV" ]; then
    log_info "Detaching loop device: $LOOP_DEV"
    losetup -d "$LOOP_DEV"
fi

echo ""
log_info "Volume closed successfully"
echo ""
echo "To reopen the volume, run: setup_encryption.sh"
`, volumeName, volumeName))
}

// LUKSSystemdService generates a systemd service for auto-mounting the encrypted volume.
func LUKSSystemdService(volumeName string) []byte {
	return []byte(fmt.Sprintf(`[Unit]
Description=Mount encrypted volume %s
After=local-fs.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/opt/homeport/scripts/setup_encryption_%s.sh
ExecStop=/opt/homeport/scripts/teardown_encryption_%s.sh

[Install]
WantedBy=multi-user.target
`, volumeName, volumeName, volumeName))
}
