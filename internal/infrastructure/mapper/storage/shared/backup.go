// Package shared provides shared utilities for storage mappers.
package shared

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/homeport/homeport/internal/domain/mapper"
)

// VolumeBackupScript generates a backup script for the volume.
func VolumeBackupScript(opts *mapper.VolumeOptions) ([]byte, error) {
	retentionDays := 7
	backupLocation := "./backups"

	if opts.Backup != nil {
		if opts.Backup.RetentionDays > 0 {
			retentionDays = opts.Backup.RetentionDays
		}
		if opts.Backup.BackupLocation != "" {
			backupLocation = opts.Backup.BackupLocation
		}
	}

	data := struct {
		*mapper.VolumeOptions
		RetentionDays  int
		BackupLocation string
	}{
		VolumeOptions:  opts,
		RetentionDays:  retentionDays,
		BackupLocation: backupLocation,
	}

	tmpl := `#!/bin/bash
# Volume Backup Script
# Volume: {{.Name}}
# Generated by Homeport
#
# Creates compressed backups of the volume data.
# Similar to cloud provider snapshots but using tar archives.

set -e

# Configuration
VOLUME_NAME="{{.Name}}"
BACKUP_DIR="${BACKUP_DIR:-{{.BackupLocation}}}"
RETENTION_DAYS="${RETENTION_DAYS:-{{.RetentionDays}}}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/${VOLUME_NAME}_${TIMESTAMP}.tar.gz"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  Volume Backup"
echo "========================================="
echo ""
echo "Volume: $VOLUME_NAME"
echo "Backup File: $BACKUP_FILE"
echo "Retention: $RETENTION_DAYS days"
echo ""

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Determine volume path
{{if .Encryption}}
VOLUME_PATH="/var/lib/homeport/mounts/${VOLUME_NAME}"
{{else if and .Quota .Quota.UseLoopDevice}}
VOLUME_PATH="/var/lib/homeport/mounts/${VOLUME_NAME}"
{{else}}
# Try Docker volume first
VOLUME_PATH=$(docker volume inspect "$VOLUME_NAME" --format '{{"{{"}} .Mountpoint {{"}}"}}' 2>/dev/null || echo "")

if [ -z "$VOLUME_PATH" ] || [ ! -d "$VOLUME_PATH" ]; then
    # Try homeport mount
    if [ -d "/var/lib/homeport/mounts/${VOLUME_NAME}" ]; then
        VOLUME_PATH="/var/lib/homeport/mounts/${VOLUME_NAME}"
    else
        VOLUME_PATH="/var/lib/docker/volumes/${VOLUME_NAME}/_data"
    fi
fi
{{end}}

log_info "Volume path: $VOLUME_PATH"

if [ ! -d "$VOLUME_PATH" ]; then
    log_warn "Volume path not found, using Docker method..."

    # Use Docker to create backup
    log_info "Creating backup via Docker..."
    docker run --rm \
        -v "${VOLUME_NAME}:/source:ro" \
        -v "$(realpath "$BACKUP_DIR"):/backup" \
        alpine \
        tar czf "/backup/${VOLUME_NAME}_${TIMESTAMP}.tar.gz" -C /source .

    BACKUP_FILE="$(realpath "$BACKUP_DIR")/${VOLUME_NAME}_${TIMESTAMP}.tar.gz"
else
    # Direct file backup
    log_info "Creating backup..."
    tar czf "$BACKUP_FILE" -C "$VOLUME_PATH" .
fi

# Verify backup
if [ -f "$BACKUP_FILE" ]; then
    BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
    log_info "Backup created: $BACKUP_FILE ($BACKUP_SIZE)"
else
    log_error "Backup failed!"
    exit 1
fi

# Create checksum
log_info "Creating checksum..."
sha256sum "$BACKUP_FILE" > "${BACKUP_FILE}.sha256"

# Clean up old backups
log_info "Cleaning up backups older than $RETENTION_DAYS days..."
find "$BACKUP_DIR" -name "${VOLUME_NAME}_*.tar.gz" -mtime +$RETENTION_DAYS -delete 2>/dev/null || true
find "$BACKUP_DIR" -name "${VOLUME_NAME}_*.tar.gz.sha256" -mtime +$RETENTION_DAYS -delete 2>/dev/null || true

# List recent backups
echo ""
echo "========================================="
echo "  Recent Backups"
echo "========================================="
ls -lh "$BACKUP_DIR"/${VOLUME_NAME}_*.tar.gz 2>/dev/null | tail -5 || echo "No backups found"

echo ""
log_info "Backup complete!"
{{if .Backup.SourceSnapshotID}}
echo ""
log_info "Note: Original cloud snapshot: {{.Backup.SourceSnapshotID}}"
{{end}}
`

	t, err := template.New("volume-backup").Parse(tmpl)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.Bytes(), nil
}

// VolumeRestoreScript generates a restore script for the volume.
func VolumeRestoreScript(opts *mapper.VolumeOptions) []byte {
	backupLocation := "./backups"
	if opts.Backup != nil && opts.Backup.BackupLocation != "" {
		backupLocation = opts.Backup.BackupLocation
	}

	return []byte(fmt.Sprintf(`#!/bin/bash
# Volume Restore Script
# Volume: %s
# Generated by Homeport
#
# Restores volume data from a backup archive.

set -e

# Configuration
VOLUME_NAME="%s"
BACKUP_DIR="${BACKUP_DIR:-%s}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

echo "========================================="
echo "  Volume Restore"
echo "========================================="
echo ""
echo "Volume: $VOLUME_NAME"
echo "Backup Directory: $BACKUP_DIR"
echo ""

# List available backups
echo "Available backups:"
echo ""
BACKUPS=$(ls -1t "$BACKUP_DIR"/${VOLUME_NAME}_*.tar.gz 2>/dev/null)

if [ -z "$BACKUPS" ]; then
    log_error "No backups found for $VOLUME_NAME in $BACKUP_DIR"
    exit 1
fi

# Number the backups
i=1
while IFS= read -r backup; do
    SIZE=$(du -h "$backup" | cut -f1)
    DATE=$(basename "$backup" | sed "s/${VOLUME_NAME}_//" | sed 's/.tar.gz//' | sed 's/_/ /')
    echo "  $i) $(basename "$backup") ($SIZE) - $DATE"
    i=$((i+1))
done <<< "$BACKUPS"

echo ""
read -p "Enter backup number to restore (or 'q' to quit): " CHOICE

if [ "$CHOICE" = "q" ]; then
    echo "Restore cancelled"
    exit 0
fi

# Get selected backup
BACKUP_FILE=$(echo "$BACKUPS" | sed -n "${CHOICE}p")

if [ -z "$BACKUP_FILE" ] || [ ! -f "$BACKUP_FILE" ]; then
    log_error "Invalid selection"
    exit 1
fi

log_info "Selected: $(basename "$BACKUP_FILE")"

# Verify checksum if available
if [ -f "${BACKUP_FILE}.sha256" ]; then
    log_info "Verifying checksum..."
    if sha256sum -c "${BACKUP_FILE}.sha256" >/dev/null 2>&1; then
        log_info "Checksum verified"
    else
        log_error "Checksum verification failed!"
        read -p "Continue anyway? (y/N): " CONTINUE
        if [ "$CONTINUE" != "y" ] && [ "$CONTINUE" != "Y" ]; then
            exit 1
        fi
    fi
fi

echo ""
log_warn "WARNING: This will overwrite existing data in volume $VOLUME_NAME"
read -p "Continue? (y/N): " CONFIRM
if [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
    echo "Restore cancelled"
    exit 0
fi

# Determine restore method
VOLUME_PATH=$(docker volume inspect "$VOLUME_NAME" --format '{{ .Mountpoint }}' 2>/dev/null || echo "")

if [ -z "$VOLUME_PATH" ] || [ ! -d "$VOLUME_PATH" ]; then
    # Try homeport mount
    if [ -d "/var/lib/homeport/mounts/${VOLUME_NAME}" ]; then
        VOLUME_PATH="/var/lib/homeport/mounts/${VOLUME_NAME}"
    fi
fi

if [ -n "$VOLUME_PATH" ] && [ -d "$VOLUME_PATH" ]; then
    # Direct restore
    log_info "Restoring to $VOLUME_PATH..."
    rm -rf "${VOLUME_PATH:?}"/*
    tar xzf "$BACKUP_FILE" -C "$VOLUME_PATH"
else
    # Use Docker to restore
    log_info "Restoring via Docker..."
    docker run --rm \
        -v "${VOLUME_NAME}:/target" \
        -v "$(realpath "$BACKUP_DIR"):/backup:ro" \
        alpine \
        sh -c "rm -rf /target/* && tar xzf /backup/$(basename "$BACKUP_FILE") -C /target"
fi

echo ""
echo "========================================="
log_info "Restore complete!"
echo "========================================="
echo ""
echo "Volume $VOLUME_NAME restored from $(basename "$BACKUP_FILE")"
`, opts.Name, opts.Name, backupLocation))
}

// BackupCronScript generates a cron-compatible backup script.
func BackupCronScript(volumeName, backupLocation string, retentionDays int) []byte {
	return []byte(fmt.Sprintf(`#!/bin/bash
# Automated Backup Script (Cron)
# Volume: %s
# Generated by Homeport
#
# Add to crontab: 0 2 * * * /opt/homeport/scripts/backup_%s_cron.sh
# This runs daily at 2 AM

VOLUME_NAME="%s"
BACKUP_DIR="%s"
RETENTION_DAYS=%d
LOG_FILE="/var/log/homeport/backup_${VOLUME_NAME}.log"

mkdir -p "$(dirname "$LOG_FILE")"
exec >> "$LOG_FILE" 2>&1

echo "========================================="
echo "Backup started: $(date)"
echo "========================================="

# Run the backup script
/opt/homeport/scripts/backup_%s.sh

echo "Backup completed: $(date)"
echo ""
`, volumeName, volumeName, volumeName, backupLocation, retentionDays, volumeName))
}

// SystemdBackupTimer generates a systemd timer for automated backups.
func SystemdBackupTimer(volumeName string) ([]byte, []byte) {
	timer := []byte(fmt.Sprintf(`[Unit]
Description=Daily backup timer for volume %s

[Timer]
OnCalendar=*-*-* 02:00:00
Persistent=true
RandomizedDelaySec=1800

[Install]
WantedBy=timers.target
`, volumeName))

	service := []byte(fmt.Sprintf(`[Unit]
Description=Backup volume %s
After=docker.service

[Service]
Type=oneshot
ExecStart=/opt/homeport/scripts/backup_%s.sh
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
`, volumeName, volumeName))

	return timer, service
}
